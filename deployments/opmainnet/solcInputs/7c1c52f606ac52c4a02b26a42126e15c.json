{
  "language": "Solidity",
  "sources": {
    "@layerzerolabs/solidity-examples/contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00), and(mload(mc), mask)))\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint _start) internal pure returns (uint) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/libraries/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint constant LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                0, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf) internal pure {\n        require(_buf.length >= 4);\n        uint _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/libs/LzLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.6.0;\npragma experimental ABIEncoderV2;\n\nlibrary LzLib {\n    // LayerZero communication\n    struct CallParams {\n        address payable refundAddress;\n        address zroPaymentAddress;\n    }\n\n    //---------------------------------------------------------------------------\n    // Address type handling\n\n    struct AirdropParams {\n        uint airdropAmount;\n        bytes32 airdropAddress;\n    }\n\n    function buildAdapterParams(LzLib.AirdropParams memory _airdropParams, uint _uaGasLimit) internal pure returns (bytes memory adapterParams) {\n        if (_airdropParams.airdropAmount == 0 && _airdropParams.airdropAddress == bytes32(0x0)) {\n            adapterParams = buildDefaultAdapterParams(_uaGasLimit);\n        } else {\n            adapterParams = buildAirdropAdapterParams(_uaGasLimit, _airdropParams);\n        }\n    }\n\n    // Build Adapter Params\n    function buildDefaultAdapterParams(uint _uaGas) internal pure returns (bytes memory) {\n        // txType 1\n        // bytes  [2       32      ]\n        // fields [txType  extraGas]\n        return abi.encodePacked(uint16(1), _uaGas);\n    }\n\n    function buildAirdropAdapterParams(uint _uaGas, AirdropParams memory _params) internal pure returns (bytes memory) {\n        require(_params.airdropAmount > 0, \"Airdrop amount must be greater than 0\");\n        require(_params.airdropAddress != bytes32(0x0), \"Airdrop address must be set\");\n\n        // txType 2\n        // bytes  [2       32        32            bytes[]         ]\n        // fields [txType  extraGas  dstNativeAmt  dstNativeAddress]\n        return abi.encodePacked(uint16(2), _uaGas, _params.airdropAmount, _params.airdropAddress);\n    }\n\n    function getGasLimit(bytes memory _adapterParams) internal pure returns (uint gasLimit) {\n        require(_adapterParams.length == 34 || _adapterParams.length > 66, \"Invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    // Decode Adapter Params\n    function decodeAdapterParams(bytes memory _adapterParams)\n        internal\n        pure\n        returns (\n            uint16 txType,\n            uint uaGas,\n            uint airdropAmount,\n            address payable airdropAddress\n        )\n    {\n        require(_adapterParams.length == 34 || _adapterParams.length > 66, \"Invalid adapterParams\");\n        assembly {\n            txType := mload(add(_adapterParams, 2))\n            uaGas := mload(add(_adapterParams, 34))\n        }\n        require(txType == 1 || txType == 2, \"Unsupported txType\");\n        require(uaGas > 0, \"Gas too low\");\n\n        if (txType == 2) {\n            assembly {\n                airdropAmount := mload(add(_adapterParams, 66))\n                airdropAddress := mload(add(_adapterParams, 86))\n            }\n        }\n    }\n\n    //---------------------------------------------------------------------------\n    // Address type handling\n    function bytes32ToAddress(bytes32 _bytes32Address) internal pure returns (address _address) {\n        return address(uint160(uint(_bytes32Address)));\n    }\n\n    function addressToBytes32(address _address) internal pure returns (bytes32 _bytes32Address) {\n        return bytes32(uint(uint160(_address)));\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"../libraries/BytesLib.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint public constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(\n            _srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote),\n            \"LzApp: invalid source sending contract\"\n        );\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint _nativeFee\n    ) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(\n        uint16 _dstChainId,\n        uint16 _type,\n        bytes memory _adapterParams,\n        uint _extraGas\n    ) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type];\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit + _extraGas, \"LzApp: gas limit is too low\");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) {\n            // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, \"LzApp: payload size is too large\");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, \"LzApp: no trusted path record\");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(\n        uint16 _dstChainId,\n        uint16 _packetType,\n        uint _minGas\n    ) external onlyOwner {\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/mocks/LZEndpointMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"../interfaces/ILayerZeroReceiver.sol\";\nimport \"../interfaces/ILayerZeroEndpoint.sol\";\nimport \"../libs/LzLib.sol\";\n\n/*\nlike a real LayerZero endpoint but can be mocked, which handle message transmission, verification, and receipt.\n- blocking: LayerZero provides ordered delivery of messages from a given sender to a destination chain.\n- non-reentrancy: endpoint has a non-reentrancy guard for both the send() and receive(), respectively.\n- adapter parameters: allows UAs to add arbitrary transaction params in the send() function, like airdrop on destination chain.\nunlike a real LayerZero endpoint, it is\n- no messaging library versioning\n- send() will short circuit to lzReceive()\n- no user application configuration\n*/\ncontract LZEndpointMock is ILayerZeroEndpoint {\n    uint8 internal constant _NOT_ENTERED = 1;\n    uint8 internal constant _ENTERED = 2;\n\n    mapping(address => address) public lzEndpointLookup;\n\n    uint16 public mockChainId;\n    bool public nextMsgBlocked;\n\n    // fee config\n    RelayerFeeConfig public relayerFeeConfig;\n    ProtocolFeeConfig public protocolFeeConfig;\n    uint public oracleFee;\n    bytes public defaultAdapterParams;\n\n    // path = remote addrss + local address\n    // inboundNonce = [srcChainId][path].\n    mapping(uint16 => mapping(bytes => uint64)) public inboundNonce;\n    //todo: this is a hack\n    // outboundNonce = [dstChainId][srcAddress]\n    mapping(uint16 => mapping(address => uint64)) public outboundNonce;\n    //    // outboundNonce = [dstChainId][path].\n    //    mapping(uint16 => mapping(bytes => uint64)) public outboundNonce;\n    // storedPayload = [srcChainId][path]\n    mapping(uint16 => mapping(bytes => StoredPayload)) public storedPayload;\n    // msgToDeliver = [srcChainId][path]\n    mapping(uint16 => mapping(bytes => QueuedPayload[])) public msgsToDeliver;\n\n    // reentrancy guard\n    uint8 internal _send_entered_state = 1;\n    uint8 internal _receive_entered_state = 1;\n\n    struct ProtocolFeeConfig {\n        uint zroFee;\n        uint nativeBP;\n    }\n\n    struct RelayerFeeConfig {\n        uint128 dstPriceRatio; // 10^10\n        uint128 dstGasPriceInWei;\n        uint128 dstNativeAmtCap;\n        uint64 baseGas;\n        uint64 gasPerByte;\n    }\n\n    struct StoredPayload {\n        uint64 payloadLength;\n        address dstAddress;\n        bytes32 payloadHash;\n    }\n\n    struct QueuedPayload {\n        address dstAddress;\n        uint64 nonce;\n        bytes payload;\n    }\n\n    modifier sendNonReentrant() {\n        require(_send_entered_state == _NOT_ENTERED, \"LayerZeroMock: no send reentrancy\");\n        _send_entered_state = _ENTERED;\n        _;\n        _send_entered_state = _NOT_ENTERED;\n    }\n\n    modifier receiveNonReentrant() {\n        require(_receive_entered_state == _NOT_ENTERED, \"LayerZeroMock: no receive reentrancy\");\n        _receive_entered_state = _ENTERED;\n        _;\n        _receive_entered_state = _NOT_ENTERED;\n    }\n\n    event UaForceResumeReceive(uint16 chainId, bytes srcAddress);\n    event PayloadCleared(uint16 srcChainId, bytes srcAddress, uint64 nonce, address dstAddress);\n    event PayloadStored(uint16 srcChainId, bytes srcAddress, address dstAddress, uint64 nonce, bytes payload, bytes reason);\n    event ValueTransferFailed(address indexed to, uint indexed quantity);\n\n    constructor(uint16 _chainId) {\n        mockChainId = _chainId;\n\n        // init config\n        relayerFeeConfig = RelayerFeeConfig({\n            dstPriceRatio: 1e10, // 1:1, same chain, same native coin\n            dstGasPriceInWei: 1e10,\n            dstNativeAmtCap: 1e19,\n            baseGas: 100,\n            gasPerByte: 1\n        });\n        protocolFeeConfig = ProtocolFeeConfig({zroFee: 1e18, nativeBP: 1000}); // BP 0.1\n        oracleFee = 1e16;\n        defaultAdapterParams = LzLib.buildDefaultAdapterParams(200000);\n    }\n\n    // ------------------------------ ILayerZeroEndpoint Functions ------------------------------\n    function send(\n        uint16 _chainId,\n        bytes memory _path,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) external payable override sendNonReentrant {\n        require(_path.length == 40, \"LayerZeroMock: incorrect remote address size\"); // only support evm chains\n\n        address dstAddr;\n        assembly {\n            dstAddr := mload(add(_path, 20))\n        }\n\n        address lzEndpoint = lzEndpointLookup[dstAddr];\n        require(lzEndpoint != address(0), \"LayerZeroMock: destination LayerZero Endpoint not found\");\n\n        // not handle zro token\n        bytes memory adapterParams = _adapterParams.length > 0 ? _adapterParams : defaultAdapterParams;\n        (uint nativeFee, ) = estimateFees(_chainId, msg.sender, _payload, _zroPaymentAddress != address(0x0), adapterParams);\n        require(msg.value >= nativeFee, \"LayerZeroMock: not enough native for fees\");\n\n        uint64 nonce = ++outboundNonce[_chainId][msg.sender];\n\n        // refund if they send too much\n        uint amount = msg.value - nativeFee;\n        if (amount > 0) {\n            (bool success, ) = _refundAddress.call{value: amount}(\"\");\n            require(success, \"LayerZeroMock: failed to refund\");\n        }\n\n        // Mock the process of receiving msg on dst chain\n        // Mock the relayer paying the dstNativeAddr the amount of extra native token\n        (, uint extraGas, uint dstNativeAmt, address payable dstNativeAddr) = LzLib.decodeAdapterParams(adapterParams);\n        if (dstNativeAmt > 0) {\n            (bool success, ) = dstNativeAddr.call{value: dstNativeAmt}(\"\");\n            if (!success) {\n                emit ValueTransferFailed(dstNativeAddr, dstNativeAmt);\n            }\n        }\n\n        bytes memory srcUaAddress = abi.encodePacked(msg.sender, dstAddr); // cast this address to bytes\n        bytes memory payload = _payload;\n        LZEndpointMock(lzEndpoint).receivePayload(mockChainId, srcUaAddress, dstAddr, nonce, extraGas, payload);\n    }\n\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _path,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external override receiveNonReentrant {\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\n\n        // assert and increment the nonce. no message shuffling\n        require(_nonce == ++inboundNonce[_srcChainId][_path], \"LayerZeroMock: wrong nonce\");\n\n        // queue the following msgs inside of a stack to simulate a successful send on src, but not fully delivered on dst\n        if (sp.payloadHash != bytes32(0)) {\n            QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_path];\n            QueuedPayload memory newMsg = QueuedPayload(_dstAddress, _nonce, _payload);\n\n            // warning, might run into gas issues trying to forward through a bunch of queued msgs\n            // shift all the msgs over so we can treat this like a fifo via array.pop()\n            if (msgs.length > 0) {\n                // extend the array\n                msgs.push(newMsg);\n\n                // shift all the indexes up for pop()\n                for (uint i = 0; i < msgs.length - 1; i++) {\n                    msgs[i + 1] = msgs[i];\n                }\n\n                // put the newMsg at the bottom of the stack\n                msgs[0] = newMsg;\n            } else {\n                msgs.push(newMsg);\n            }\n        } else if (nextMsgBlocked) {\n            storedPayload[_srcChainId][_path] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n            emit PayloadStored(_srcChainId, _path, _dstAddress, _nonce, _payload, bytes(\"\"));\n            // ensure the next msgs that go through are no longer blocked\n            nextMsgBlocked = false;\n        } else {\n            try ILayerZeroReceiver(_dstAddress).lzReceive{gas: _gasLimit}(_srcChainId, _path, _nonce, _payload) {} catch (bytes memory reason) {\n                storedPayload[_srcChainId][_path] = StoredPayload(uint64(_payload.length), _dstAddress, keccak256(_payload));\n                emit PayloadStored(_srcChainId, _path, _dstAddress, _nonce, _payload, reason);\n                // ensure the next msgs that go through are no longer blocked\n                nextMsgBlocked = false;\n            }\n        }\n    }\n\n    function getInboundNonce(uint16 _chainID, bytes calldata _path) external view override returns (uint64) {\n        return inboundNonce[_chainID][_path];\n    }\n\n    function getOutboundNonce(uint16 _chainID, address _srcAddress) external view override returns (uint64) {\n        return outboundNonce[_chainID][_srcAddress];\n    }\n\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes memory _payload,\n        bool _payInZRO,\n        bytes memory _adapterParams\n    ) public view override returns (uint nativeFee, uint zroFee) {\n        bytes memory adapterParams = _adapterParams.length > 0 ? _adapterParams : defaultAdapterParams;\n\n        // Relayer Fee\n        uint relayerFee = _getRelayerFee(_dstChainId, 1, _userApplication, _payload.length, adapterParams);\n\n        // LayerZero Fee\n        uint protocolFee = _getProtocolFees(_payInZRO, relayerFee, oracleFee);\n        _payInZRO ? zroFee = protocolFee : nativeFee = protocolFee;\n\n        // return the sum of fees\n        nativeFee = nativeFee + relayerFee + oracleFee;\n    }\n\n    function getChainId() external view override returns (uint16) {\n        return mockChainId;\n    }\n\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _path,\n        bytes calldata _payload\n    ) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\n        require(sp.payloadHash != bytes32(0), \"LayerZeroMock: no stored payload\");\n        require(_payload.length == sp.payloadLength && keccak256(_payload) == sp.payloadHash, \"LayerZeroMock: invalid payload\");\n\n        address dstAddress = sp.dstAddress;\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        uint64 nonce = inboundNonce[_srcChainId][_path];\n\n        ILayerZeroReceiver(dstAddress).lzReceive(_srcChainId, _path, nonce, _payload);\n        emit PayloadCleared(_srcChainId, _path, nonce, dstAddress);\n    }\n\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _path) external view override returns (bool) {\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\n        return sp.payloadHash != bytes32(0);\n    }\n\n    function getSendLibraryAddress(address) external view override returns (address) {\n        return address(this);\n    }\n\n    function getReceiveLibraryAddress(address) external view override returns (address) {\n        return address(this);\n    }\n\n    function isSendingPayload() external view override returns (bool) {\n        return _send_entered_state == _ENTERED;\n    }\n\n    function isReceivingPayload() external view override returns (bool) {\n        return _receive_entered_state == _ENTERED;\n    }\n\n    function getConfig(\n        uint16, /*_version*/\n        uint16, /*_chainId*/\n        address, /*_ua*/\n        uint /*_configType*/\n    ) external pure override returns (bytes memory) {\n        return \"\";\n    }\n\n    function getSendVersion(\n        address /*_userApplication*/\n    ) external pure override returns (uint16) {\n        return 1;\n    }\n\n    function getReceiveVersion(\n        address /*_userApplication*/\n    ) external pure override returns (uint16) {\n        return 1;\n    }\n\n    function setConfig(\n        uint16, /*_version*/\n        uint16, /*_chainId*/\n        uint, /*_configType*/\n        bytes memory /*_config*/\n    ) external override {}\n\n    function setSendVersion(\n        uint16 /*version*/\n    ) external override {}\n\n    function setReceiveVersion(\n        uint16 /*version*/\n    ) external override {}\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _path) external override {\n        StoredPayload storage sp = storedPayload[_srcChainId][_path];\n        // revert if no messages are cached. safeguard malicious UA behaviour\n        require(sp.payloadHash != bytes32(0), \"LayerZeroMock: no stored payload\");\n        require(sp.dstAddress == msg.sender, \"LayerZeroMock: invalid caller\");\n\n        // empty the storedPayload\n        sp.payloadLength = 0;\n        sp.dstAddress = address(0);\n        sp.payloadHash = bytes32(0);\n\n        emit UaForceResumeReceive(_srcChainId, _path);\n\n        // resume the receiving of msgs after we force clear the \"stuck\" msg\n        _clearMsgQue(_srcChainId, _path);\n    }\n\n    // ------------------------------ Other Public/External Functions --------------------------------------------------\n\n    function getLengthOfQueue(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint) {\n        return msgsToDeliver[_srcChainId][_srcAddress].length;\n    }\n\n    // used to simulate messages received get stored as a payload\n    function blockNextMsg() external {\n        nextMsgBlocked = true;\n    }\n\n    function setDestLzEndpoint(address destAddr, address lzEndpointAddr) external {\n        lzEndpointLookup[destAddr] = lzEndpointAddr;\n    }\n\n    function setRelayerPrice(\n        uint128 _dstPriceRatio,\n        uint128 _dstGasPriceInWei,\n        uint128 _dstNativeAmtCap,\n        uint64 _baseGas,\n        uint64 _gasPerByte\n    ) external {\n        relayerFeeConfig.dstPriceRatio = _dstPriceRatio;\n        relayerFeeConfig.dstGasPriceInWei = _dstGasPriceInWei;\n        relayerFeeConfig.dstNativeAmtCap = _dstNativeAmtCap;\n        relayerFeeConfig.baseGas = _baseGas;\n        relayerFeeConfig.gasPerByte = _gasPerByte;\n    }\n\n    function setProtocolFee(uint _zroFee, uint _nativeBP) external {\n        protocolFeeConfig.zroFee = _zroFee;\n        protocolFeeConfig.nativeBP = _nativeBP;\n    }\n\n    function setOracleFee(uint _oracleFee) external {\n        oracleFee = _oracleFee;\n    }\n\n    function setDefaultAdapterParams(bytes memory _adapterParams) external {\n        defaultAdapterParams = _adapterParams;\n    }\n\n    // --------------------- Internal Functions ---------------------\n    // simulates the relayer pushing through the rest of the msgs that got delayed due to the stored payload\n    function _clearMsgQue(uint16 _srcChainId, bytes calldata _path) internal {\n        QueuedPayload[] storage msgs = msgsToDeliver[_srcChainId][_path];\n\n        // warning, might run into gas issues trying to forward through a bunch of queued msgs\n        while (msgs.length > 0) {\n            QueuedPayload memory payload = msgs[msgs.length - 1];\n            ILayerZeroReceiver(payload.dstAddress).lzReceive(_srcChainId, _path, payload.nonce, payload.payload);\n            msgs.pop();\n        }\n    }\n\n    function _getProtocolFees(\n        bool _payInZro,\n        uint _relayerFee,\n        uint _oracleFee\n    ) internal view returns (uint) {\n        if (_payInZro) {\n            return protocolFeeConfig.zroFee;\n        } else {\n            return ((_relayerFee + _oracleFee) * protocolFeeConfig.nativeBP) / 10000;\n        }\n    }\n\n    function _getRelayerFee(\n        uint16, /* _dstChainId */\n        uint16, /* _outboundProofType */\n        address, /* _userApplication */\n        uint _payloadSize,\n        bytes memory _adapterParams\n    ) internal view returns (uint) {\n        (uint16 txType, uint extraGas, uint dstNativeAmt, ) = LzLib.decodeAdapterParams(_adapterParams);\n        uint totalRemoteToken; // = baseGas + extraGas + requiredNativeAmount\n        if (txType == 2) {\n            require(relayerFeeConfig.dstNativeAmtCap >= dstNativeAmt, \"LayerZeroMock: dstNativeAmt too large \");\n            totalRemoteToken += dstNativeAmt;\n        }\n        // remoteGasTotal = dstGasPriceInWei * (baseGas + extraGas)\n        uint remoteGasTotal = relayerFeeConfig.dstGasPriceInWei * (relayerFeeConfig.baseGas + extraGas);\n        totalRemoteToken += remoteGasTotal;\n\n        // tokenConversionRate = dstPrice / localPrice\n        // basePrice = totalRemoteToken * tokenConversionRate\n        uint basePrice = (totalRemoteToken * relayerFeeConfig.dstPriceRatio) / 10**10;\n\n        // pricePerByte = (dstGasPriceInWei * gasPerBytes) * tokenConversionRate\n        uint pricePerByte = (relayerFeeConfig.dstGasPriceInWei * relayerFeeConfig.gasPerByte * relayerFeeConfig.dstPriceRatio) / 10**10;\n\n        return basePrice + _payloadSize * pricePerByte;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LzApp.sol\";\nimport \"../libraries/ExcessivelySafeCall.sol\";\n\n/*\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\n */\nabstract contract NonblockingLzApp is LzApp {\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload)\n        );\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload,\n        bytes memory _reason\n    ) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/Ownable2Step.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./OwnableUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\n    function __Ownable2Step_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\n    }\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() external {\n        address sender = _msgSender();\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\n        _transferOwnership(sender);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@venusprotocol/solidity-utilities/contracts/validators.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\nerror ZeroAddressNotAllowed();\n\n/// @notice Thrown if the supplied value is 0 where it is not allowed\nerror ZeroValueNotAllowed();\n\n/// @notice Checks if the provided address is nonzero, reverts otherwise\n/// @param address_ Address to check\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\nfunction ensureNonzeroAddress(address address_) pure {\n    if (address_ == address(0)) {\n        revert ZeroAddressNotAllowed();\n    }\n}\n\n/// @notice Checks if the provided value is nonzero, reverts otherwise\n/// @param value_ Value to check\n/// @custom:error ZeroValueNotAllowed is thrown if the provided value is 0\nfunction ensureNonzeroValue(uint256 value_) pure {\n    if (value_ == 0) {\n        revert ZeroValueNotAllowed();\n    }\n}\n"
    },
    "contracts/Cross-chain/BaseOmnichainControllerDest.sol": {
      "content": "//  SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { NonblockingLzApp } from \"@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol\";\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\n/**\n * @title BaseOmnichainControllerDest\n * @author Venus\n * @dev This contract is the base for the Omnichain controller destination contract\n * It provides functionality related to daily command limits and pausability\n * @custom:security-contact https://github.com/VenusProtocol/governance-contracts#discussion\n */\n\nabstract contract BaseOmnichainControllerDest is NonblockingLzApp, Pausable {\n    /**\n     * @notice Maximum daily limit for receiving commands from Binance chain\n     */\n    uint256 public maxDailyReceiveLimit;\n\n    /**\n     * @notice Total received commands within the last 24-hour window from Binance chain\n     */\n    uint256 public last24HourCommandsReceived;\n\n    /**\n     * @notice Timestamp when the last 24-hour window started from Binance chain\n     */\n    uint256 public last24HourReceiveWindowStart;\n\n    /**\n     * @notice Emitted when the maximum daily limit for receiving command from Binance chain is modified\n     */\n    event SetMaxDailyReceiveLimit(uint256 oldMaxLimit, uint256 newMaxLimit);\n\n    constructor(address endpoint_) NonblockingLzApp(endpoint_) {\n        ensureNonzeroAddress(endpoint_);\n    }\n\n    /**\n     * @notice Sets the maximum daily limit for receiving commands\n     * @param limit_ Number of commands\n     * @custom:access Only Owner\n     * @custom:event Emits SetMaxDailyReceiveLimit with old and new limit\n     */\n    function setMaxDailyReceiveLimit(uint256 limit_) external onlyOwner {\n        emit SetMaxDailyReceiveLimit(maxDailyReceiveLimit, limit_);\n        maxDailyReceiveLimit = limit_;\n    }\n\n    /**\n     * @notice Triggers the paused state of the controller\n     * @custom:access Only owner\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @notice Triggers the resume state of the controller\n     * @custom:access Only owner\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @notice Empty implementation of renounce ownership to avoid any mishappening\n     */\n    function renounceOwnership() public override {}\n\n    /**\n     * @notice Check eligibility to receive commands\n     * @param noOfCommands_ Number of commands to be received\n     */\n    function _isEligibleToReceive(uint256 noOfCommands_) internal {\n        uint256 currentBlockTimestamp = block.timestamp;\n\n        // Load values for the 24-hour window checks for receiving\n        uint256 receivedInWindow = last24HourCommandsReceived;\n\n        // Check if the time window has changed (more than 24 hours have passed)\n        if (currentBlockTimestamp - last24HourReceiveWindowStart > 1 days) {\n            receivedInWindow = noOfCommands_;\n            last24HourReceiveWindowStart = currentBlockTimestamp;\n        } else {\n            receivedInWindow += noOfCommands_;\n        }\n\n        // Revert if the received amount exceeds the daily limit\n        require(receivedInWindow <= maxDailyReceiveLimit, \"Daily Transaction Limit Exceeded\");\n\n        // Update the received amount for the 24-hour window\n        last24HourCommandsReceived = receivedInWindow;\n    }\n}\n"
    },
    "contracts/Cross-chain/BaseOmnichainControllerSrc.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\n\npragma solidity 0.8.25;\n\nimport { Pausable } from \"@openzeppelin/contracts/security/Pausable.sol\";\nimport { Ownable } from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { IAccessControlManagerV8 } from \"./../Governance/IAccessControlManagerV8.sol\";\n\n/**\n * @title BaseOmnichainControllerSrc\n * @dev This contract is the base for the Omnichain controller source contracts.\n * It provides functionality related to daily command limits and pausability.\n * @custom:security-contact https://github.com/VenusProtocol/governance-contracts#discussion\n */\n\ncontract BaseOmnichainControllerSrc is Ownable, Pausable {\n    /**\n     * @notice ACM (Access Control Manager) contract address\n     */\n    address public accessControlManager;\n\n    /**\n     * @notice Maximum daily limit for commands from the local chain\n     */\n    mapping(uint16 => uint256) public chainIdToMaxDailyLimit;\n\n    /**\n     * @notice Total commands transferred within the last 24-hour window from the local chain\n     */\n    mapping(uint16 => uint256) public chainIdToLast24HourCommandsSent;\n\n    /**\n     * @notice Timestamp when the last 24-hour window started from the local chain\n     */\n    mapping(uint16 => uint256) public chainIdToLast24HourWindowStart;\n    /**\n     * @notice Timestamp when the last proposal sent from the local chain to dest chain\n     */\n    mapping(uint16 => uint256) public chainIdToLastProposalSentTimestamp;\n\n    /**\n     * @notice Emitted when the maximum daily limit of commands from the local chain is modified\n     */\n    event SetMaxDailyLimit(uint16 indexed chainId, uint256 oldMaxLimit, uint256 newMaxLimit);\n    /*\n     * @notice Emitted when the address of ACM is updated\n     */\n    event NewAccessControlManager(address indexed oldAccessControlManager, address indexed newAccessControlManager);\n\n    constructor(address accessControlManager_) {\n        ensureNonzeroAddress(accessControlManager_);\n        accessControlManager = accessControlManager_;\n    }\n\n    /**\n     * @notice Sets the limit of daily (24 Hour) command amount\n     * @param chainId_ Destination chain id\n     * @param limit_ Number of commands\n     * @custom:access Controlled by AccessControlManager\n     * @custom:event Emits SetMaxDailyLimit with old and new limit and its corresponding chain id\n     */\n    function setMaxDailyLimit(uint16 chainId_, uint256 limit_) external {\n        _ensureAllowed(\"setMaxDailyLimit(uint16,uint256)\");\n        emit SetMaxDailyLimit(chainId_, chainIdToMaxDailyLimit[chainId_], limit_);\n        chainIdToMaxDailyLimit[chainId_] = limit_;\n    }\n\n    /**\n     * @notice Triggers the paused state of the controller\n     * @custom:access Controlled by AccessControlManager\n     */\n    function pause() external {\n        _ensureAllowed(\"pause()\");\n        _pause();\n    }\n\n    /**\n     * @notice Triggers the resume state of the controller\n     * @custom:access Controlled by AccessControlManager\n     */\n    function unpause() external {\n        _ensureAllowed(\"unpause()\");\n        _unpause();\n    }\n\n    /**\n     * @notice Sets the address of Access Control Manager (ACM)\n     * @param accessControlManager_ The new address of the Access Control Manager\n     * @custom:access Only owner\n     * @custom:event Emits NewAccessControlManager with old and new access control manager addresses\n     */\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\n        ensureNonzeroAddress(accessControlManager_);\n        emit NewAccessControlManager(accessControlManager, accessControlManager_);\n        accessControlManager = accessControlManager_;\n    }\n\n    /**\n     * @notice Empty implementation of renounce ownership to avoid any mishap\n     */\n    function renounceOwnership() public override {}\n\n    /**\n     * @notice Check eligibility to send commands\n     * @param dstChainId_ Destination chain id\n     * @param noOfCommands_ Number of commands to send\n     */\n    function _isEligibleToSend(uint16 dstChainId_, uint256 noOfCommands_) internal {\n        // Load values for the 24-hour window checks\n        uint256 currentBlockTimestamp = block.timestamp;\n        uint256 lastDayWindowStart = chainIdToLast24HourWindowStart[dstChainId_];\n        uint256 commandsSentInWindow = chainIdToLast24HourCommandsSent[dstChainId_];\n        uint256 maxDailyLimit = chainIdToMaxDailyLimit[dstChainId_];\n        uint256 lastProposalSentTimestamp = chainIdToLastProposalSentTimestamp[dstChainId_];\n\n        // Check if the time window has changed (more than 24 hours have passed)\n        if (currentBlockTimestamp - lastDayWindowStart > 1 days) {\n            commandsSentInWindow = noOfCommands_;\n            chainIdToLast24HourWindowStart[dstChainId_] = currentBlockTimestamp;\n        } else {\n            commandsSentInWindow += noOfCommands_;\n        }\n\n        // Revert if the amount exceeds the daily limit\n        require(commandsSentInWindow <= maxDailyLimit, \"Daily Transaction Limit Exceeded\");\n        // Revert if the last proposal is already sent in current block i.e multiple proposals cannot be sent within the same block.timestamp\n        require(lastProposalSentTimestamp != currentBlockTimestamp, \"Multiple bridging in a proposal\");\n\n        // Update the amount for the 24-hour window\n        chainIdToLast24HourCommandsSent[dstChainId_] = commandsSentInWindow;\n        // Update the last sent proposal timestamp\n        chainIdToLastProposalSentTimestamp[dstChainId_] = currentBlockTimestamp;\n    }\n\n    /**\n     * @notice Ensure that the caller has permission to execute a specific function\n     * @param functionSig_ Function signature to be checked for permission\n     */\n    function _ensureAllowed(string memory functionSig_) internal view {\n        require(\n            IAccessControlManagerV8(accessControlManager).isAllowedToCall(msg.sender, functionSig_),\n            \"access denied\"\n        );\n    }\n}\n"
    },
    "contracts/Cross-chain/interfaces/IOmnichainGovernanceExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.25;\n\ninterface IOmnichainGovernanceExecutor {\n    /**\n     * @notice Transfers ownership of the contract to the specified address\n     * @param addr The address to which ownership will be transferred\n     */\n    function transferOwnership(address addr) external;\n\n    /**\n     * @notice Sets the source message sender address\n     * @param srcChainId_ The LayerZero id of a source chain\n     * @param srcAddress_ The address of the contract on the source chain\n     */\n    function setTrustedRemoteAddress(uint16 srcChainId_, bytes calldata srcAddress_) external;\n}\n"
    },
    "contracts/Cross-chain/interfaces/ITimelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\n/**\n * @title ITimelock\n * @author Venus\n * @dev Interface for Timelock contract\n * @custom:security-contact https://github.com/VenusProtocol/governance-contracts#discussion\n */\ninterface ITimelock {\n    /**\n     * @notice Delay period for the transaction queue\n     */\n    function delay() external view returns (uint256);\n\n    /**\n     * @notice Required period to execute a proposal transaction\n     */\n    function GRACE_PERIOD() external view returns (uint256);\n\n    /**\n     * @notice Method for accepting a proposed admin\n     */\n    function acceptAdmin() external;\n\n    /**\n     * @notice Method to propose a new admin authorized to call timelock functions. This should be the Governor Contract.\n     */\n    function setPendingAdmin(address pendingAdmin) external;\n\n    /**\n     * @notice Show mapping of queued transactions\n     * @param hash Transaction hash\n     */\n    function queuedTransactions(bytes32 hash) external view returns (bool);\n\n    /**\n     * @notice Called for each action when queuing a proposal\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @return Hash of the queued transaction\n     */\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external returns (bytes32);\n\n    /**\n     * @notice Called to cancel a queued transaction\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     */\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external;\n\n    /**\n     * @notice Called to execute a queued transaction\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @return Result of function call\n     */\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) external payable returns (bytes memory);\n}\n"
    },
    "contracts/Cross-chain/OmnichainExecutorOwner.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { AccessControlledV8 } from \"../Governance/AccessControlledV8.sol\";\nimport { IOmnichainGovernanceExecutor } from \"./interfaces/IOmnichainGovernanceExecutor.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\n/**\n * @title OmnichainExecutorOwner\n * @author Venus\n * @notice OmnichainProposalSender contract acts as a governance and access control mechanism,\n * allowing owner to upsert signature of OmnichainGovernanceExecutor contract,\n * also contains function to transfer the ownership of contract as well.\n * @custom:security-contact https://github.com/VenusProtocol/governance-contracts#discussion\n */\n\ncontract OmnichainExecutorOwner is AccessControlledV8 {\n    /**\n     *  @custom:oz-upgrades-unsafe-allow state-variable-immutable\n     */\n    IOmnichainGovernanceExecutor public immutable OMNICHAIN_GOVERNANCE_EXECUTOR;\n\n    /**\n     * @notice Stores function signature corresponding to their 4 bytes hash value\n     */\n    mapping(bytes4 => string) public functionRegistry;\n\n    /**\n     * @notice Event emitted when function registry updated\n     */\n    event FunctionRegistryChanged(string indexed signature, bool active);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor(address omnichainGovernanceExecutor_) {\n        require(omnichainGovernanceExecutor_ != address(0), \"Address must not be zero\");\n        OMNICHAIN_GOVERNANCE_EXECUTOR = IOmnichainGovernanceExecutor(omnichainGovernanceExecutor_);\n        _disableInitializers();\n    }\n\n    /**\n     * @notice Initialize the contract\n     * @param accessControlManager_  Address of access control manager\n     */\n    function initialize(address accessControlManager_) external initializer {\n        require(accessControlManager_ != address(0), \"Address must not be zero\");\n        __AccessControlled_init(accessControlManager_);\n    }\n\n    /**\n     * @notice Sets the source message sender address\n     * @param srcChainId_ The LayerZero id of a source chain\n     * @param srcAddress_ The address of the contract on the source chain\n     * @custom:access Controlled by AccessControlManager\n     * @custom:event Emits SetTrustedRemoteAddress with source chain Id and source address\n     */\n    function setTrustedRemoteAddress(uint16 srcChainId_, bytes calldata srcAddress_) external {\n        _checkAccessAllowed(\"setTrustedRemoteAddress(uint16,bytes)\");\n        require(srcChainId_ != 0, \"ChainId must not be zero\");\n        ensureNonzeroAddress(address(uint160(bytes20(srcAddress_))));\n        require(srcAddress_.length == 20, \"Source address must be 20 bytes long\");\n        OMNICHAIN_GOVERNANCE_EXECUTOR.setTrustedRemoteAddress(srcChainId_, srcAddress_);\n    }\n\n    /**\n     * @notice Invoked when called function does not exist in the contract\n     * @param data_ Calldata containing the encoded function call\n     * @return Result of function call\n     * @custom:access Controlled by Access Control Manager\n     */\n    fallback(bytes calldata data_) external returns (bytes memory) {\n        string memory fun = functionRegistry[msg.sig];\n        require(bytes(fun).length != 0, \"Function not found\");\n        _checkAccessAllowed(fun);\n        (bool ok, bytes memory res) = address(OMNICHAIN_GOVERNANCE_EXECUTOR).call(data_);\n        require(ok, \"call failed\");\n        return res;\n    }\n\n    /**\n     * @notice A registry of functions that are allowed to be executed from proposals\n     * @param signatures_  Function signature to be added or removed\n     * @param active_ bool value, should be true to add function\n     * @custom:access Only owner\n     */\n    function upsertSignature(string[] calldata signatures_, bool[] calldata active_) external onlyOwner {\n        uint256 signatureLength = signatures_.length;\n        require(signatureLength == active_.length, \"Input arrays must have the same length\");\n        for (uint256 i; i < signatureLength; ++i) {\n            bytes4 sigHash = bytes4(keccak256(bytes(signatures_[i])));\n            bytes memory signature = bytes(functionRegistry[sigHash]);\n            if (active_[i] && signature.length == 0) {\n                functionRegistry[sigHash] = signatures_[i];\n                emit FunctionRegistryChanged(signatures_[i], true);\n            } else if (!active_[i] && signature.length != 0) {\n                delete functionRegistry[sigHash];\n                emit FunctionRegistryChanged(signatures_[i], false);\n            }\n        }\n    }\n\n    /**\n     * @notice This function transfer the ownership of the executor from this contract to new owner\n     * @param newOwner_ New owner of the governanceExecutor\n     * @custom:access Controlled by AccessControlManager\n     */\n\n    function transferBridgeOwnership(address newOwner_) external {\n        _checkAccessAllowed(\"transferBridgeOwnership(address)\");\n        require(newOwner_ != address(0), \"Address must not be zero\");\n        OMNICHAIN_GOVERNANCE_EXECUTOR.transferOwnership(newOwner_);\n    }\n\n    /**\n     *  @notice Empty implementation of renounce ownership to avoid any mishappening\n     */\n    function renounceOwnership() public virtual override {}\n}\n"
    },
    "contracts/Cross-chain/OmnichainGovernanceExecutor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.25;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { BytesLib } from \"@layerzerolabs/solidity-examples/contracts/libraries/BytesLib.sol\";\nimport { ExcessivelySafeCall } from \"@layerzerolabs/solidity-examples/contracts/libraries/ExcessivelySafeCall.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { BaseOmnichainControllerDest } from \"./BaseOmnichainControllerDest.sol\";\nimport { ITimelock } from \"./interfaces/ITimelock.sol\";\n\n/**\n * @title OmnichainGovernanceExecutor\n * @notice Executes the proposal transactions sent from the main chain\n * @dev The owner of this contract controls LayerZero configuration. When used in production the owner will be OmnichainExecutor\n * This implementation is non-blocking, meaning the failed messages will not block the future messages from the source.\n * For the blocking behavior, derive the contract from LzApp.\n * @custom:security-contact https://github.com/VenusProtocol/governance-contracts#discussion\n */\ncontract OmnichainGovernanceExecutor is ReentrancyGuard, BaseOmnichainControllerDest {\n    using BytesLib for bytes;\n    using ExcessivelySafeCall for address;\n\n    enum ProposalType {\n        NORMAL,\n        FASTTRACK,\n        CRITICAL\n    }\n\n    struct Proposal {\n        /** Unique id for looking up a proposal */\n        uint256 id;\n        /** The timestamp that the proposal will be available for execution, set once the vote succeeds */\n        uint256 eta;\n        /** The ordered list of target addresses for calls to be made */\n        address[] targets;\n        /** The ordered list of values (i.e. msg.value) to be passed to the calls to be made */\n        uint256[] values;\n        /** The ordered list of function signatures to be called */\n        string[] signatures;\n        /** The ordered list of calldata to be passed to each call */\n        bytes[] calldatas;\n        /** Flag marking whether the proposal has been canceled */\n        bool canceled;\n        /** Flag marking whether the proposal has been executed */\n        bool executed;\n        /** The type of the proposal */\n        uint8 proposalType;\n    }\n    /*\n     * @notice Possible states that a proposal may be in\n     */\n    enum ProposalState {\n        Canceled,\n        Queued,\n        Executed\n    }\n\n    /**\n     * @notice A privileged role that can cancel any proposal\n     */\n    address public guardian;\n\n    /**\n     * @notice Stores BNB chain layerzero endpoint id\n     */\n    uint16 public srcChainId;\n\n    /**\n     * @notice Last proposal count received\n     */\n    uint256 public lastProposalReceived;\n\n    /**\n     * @notice The official record of all proposals ever proposed\n     */\n    mapping(uint256 => Proposal) public proposals;\n\n    /**\n     * @notice Mapping containing Timelock addresses for each proposal type\n     */\n    mapping(uint256 => ITimelock) public proposalTimelocks;\n\n    /**\n     * @notice Represents queue state of proposal\n     */\n    mapping(uint256 => bool) public queued;\n\n    /**\n     * @notice Emitted when proposal is received\n     */\n    event ProposalReceived(\n        uint256 indexed proposalId,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint8 proposalType\n    );\n\n    /**\n     * @notice Emitted when proposal is queued\n     */\n    event ProposalQueued(uint256 indexed id, uint256 eta);\n\n    /**\n     * Emitted when proposal executed\n     */\n    event ProposalExecuted(uint256 indexed id);\n\n    /**\n     * @notice Emitted when proposal failed\n     */\n    event ReceivePayloadFailed(uint16 indexed srcChainId, bytes indexed srcAddress, uint64 nonce, bytes reason);\n\n    /**\n     * @notice Emitted when proposal is canceled\n     */\n    event ProposalCanceled(uint256 indexed id);\n\n    /**\n     * @notice Emitted when timelock added\n     */\n    event TimelockAdded(uint8 routeType, address indexed oldTimelock, address indexed newTimelock);\n\n    /**\n     * @notice Emitted when source layerzero endpoint id is updated\n     */\n    event SetSrcChainId(uint16 indexed oldSrcChainId, uint16 indexed newSrcChainId);\n\n    /**\n     * @notice Emitted when new guardian address is set\n     */\n    event NewGuardian(address indexed oldGuardian, address indexed newGuardian);\n\n    /**\n     * @notice Emitted when pending admin of Timelock is updated\n     */\n    event SetTimelockPendingAdmin(address, uint8);\n\n    /**\n     * @notice Thrown when proposal ID is invalid\n     */\n    error InvalidProposalId();\n\n    constructor(address endpoint_, address guardian_, uint16 srcChainId_) BaseOmnichainControllerDest(endpoint_) {\n        ensureNonzeroAddress(guardian_);\n        guardian = guardian_;\n        srcChainId = srcChainId_;\n    }\n\n    /**\n     * @notice Update source layerzero endpoint id\n     * @param srcChainId_ The new source chain id to be set\n     * @custom:event Emit SetSrcChainId with old and new source id\n     * @custom:access Only owner\n     */\n    function setSrcChainId(uint16 srcChainId_) external onlyOwner {\n        emit SetSrcChainId(srcChainId, srcChainId_);\n        srcChainId = srcChainId_;\n    }\n\n    /**\n     * @notice Sets the new executor guardian\n     * @param newGuardian The address of the new guardian\n     * @custom:access Must be call by guardian or owner\n     * @custom:event Emit NewGuardian with old and new guardian address\n     */\n    function setGuardian(address newGuardian) external {\n        require(\n            msg.sender == guardian || msg.sender == owner(),\n            \"OmnichainGovernanceExecutor::setGuardian: owner or guardian only\"\n        );\n        ensureNonzeroAddress(newGuardian);\n        emit NewGuardian(guardian, newGuardian);\n        guardian = newGuardian;\n    }\n\n    /**\n     * @notice Add timelocks to the ProposalTimelocks mapping\n     * @param timelocks_ Array of addresses of all 3 timelocks\n     * @custom:access Only owner\n     * @custom:event Emits TimelockAdded with old and new timelock and route type\n     */\n    function addTimelocks(ITimelock[] memory timelocks_) external onlyOwner {\n        uint8 length = uint8(type(ProposalType).max) + 1;\n        require(\n            timelocks_.length == length,\n            \"OmnichainGovernanceExecutor::addTimelocks:number of timelocks should match the number of governance routes\"\n        );\n        for (uint8 i; i < length; ++i) {\n            ensureNonzeroAddress(address(timelocks_[i]));\n            emit TimelockAdded(i, address(proposalTimelocks[i]), address(timelocks_[i]));\n            proposalTimelocks[i] = timelocks_[i];\n        }\n    }\n\n    /**\n     * @notice Executes a queued proposal if eta has passed\n     * @param proposalId_ Id of proposal that is to be executed\n     * @custom:event Emits ProposalExecuted with proposal id of executed proposal\n     */\n    function execute(uint256 proposalId_) external nonReentrant {\n        require(\n            state(proposalId_) == ProposalState.Queued,\n            \"OmnichainGovernanceExecutor::execute: proposal can only be executed if it is queued\"\n        );\n\n        Proposal storage proposal = proposals[proposalId_];\n        proposal.executed = true;\n        ITimelock timelock = proposalTimelocks[proposal.proposalType];\n        uint256 eta = proposal.eta;\n        uint256 length = proposal.targets.length;\n\n        emit ProposalExecuted(proposalId_);\n\n        for (uint256 i; i < length; ++i) {\n            timelock.executeTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        delete queued[proposalId_];\n    }\n\n    /**\n     * @notice Cancels a proposal only if sender is the guardian and proposal is not executed\n     * @param proposalId_ Id of proposal that is to be canceled\n     * @custom:access Sender must be the guardian\n     * @custom:event Emits ProposalCanceled with proposal id of the canceled proposal\n     */\n    function cancel(uint256 proposalId_) external {\n        require(\n            state(proposalId_) == ProposalState.Queued,\n            \"OmnichainGovernanceExecutor::cancel: proposal should be queued and not executed\"\n        );\n        Proposal storage proposal = proposals[proposalId_];\n        require(msg.sender == guardian, \"OmnichainGovernanceExecutor::cancel: sender must be guardian\");\n\n        proposal.canceled = true;\n        ITimelock timelock = proposalTimelocks[proposal.proposalType];\n        uint256 eta = proposal.eta;\n        uint256 length = proposal.targets.length;\n\n        emit ProposalCanceled(proposalId_);\n\n        for (uint256 i; i < length; ++i) {\n            timelock.cancelTransaction(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta\n            );\n        }\n        delete queued[proposalId_];\n    }\n\n    /**\n     * @notice Sets the new pending admin of the Timelock\n     * @param pendingAdmin_ Address of new pending admin\n     * @param proposalType_ Type of proposal\n     * @custom:access Only owner\n     * @custom:event Emits SetTimelockPendingAdmin with new pending admin and proposal type\n     */\n    function setTimelockPendingAdmin(address pendingAdmin_, uint8 proposalType_) external onlyOwner {\n        uint8 proposalTypeLength = uint8(type(ProposalType).max) + 1;\n        require(\n            proposalType_ < proposalTypeLength,\n            \"OmnichainGovernanceExecutor::setTimelockPendingAdmin: invalid proposal type\"\n        );\n\n        proposalTimelocks[proposalType_].setPendingAdmin(pendingAdmin_);\n        emit SetTimelockPendingAdmin(pendingAdmin_, proposalType_);\n    }\n\n    /**\n     * @notice Resends a previously failed message\n     * @param srcChainId_ Source chain Id\n     * @param srcAddress_ Source address => local app address + remote app address\n     * @param nonce_ Nonce to identify failed message\n     * @param payload_ The payload of the message to be retried\n     * @custom:access Only owner\n     */\n    function retryMessage(\n        uint16 srcChainId_,\n        bytes calldata srcAddress_,\n        uint64 nonce_,\n        bytes calldata payload_\n    ) public payable override onlyOwner nonReentrant {\n        require(\n            keccak256(trustedRemoteLookup[srcChainId_]) == keccak256(srcAddress_),\n            \"OmnichainGovernanceExecutor::retryMessage: not a trusted remote\"\n        );\n        super.retryMessage(srcChainId_, srcAddress_, nonce_, payload_);\n    }\n\n    /**\n     * @notice Gets the state of a proposal\n     * @param proposalId_ The id of the proposal\n     * @return Proposal state\n     */\n    function state(uint256 proposalId_) public view returns (ProposalState) {\n        Proposal storage proposal = proposals[proposalId_];\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        } else if (proposal.executed) {\n            return ProposalState.Executed;\n        } else if (queued[proposalId_]) {\n            // queued only when proposal is received\n            return ProposalState.Queued;\n        } else {\n            revert InvalidProposalId();\n        }\n    }\n\n    /**\n     * @notice Process blocking LayerZero receive request\n     * @param srcChainId_ Source chain Id\n     * @param srcAddress_ Source address from which payload is received\n     * @param nonce_ Nonce associated with the payload to prevent replay attacks\n     * @param payload_ Encoded payload containing proposal information\n     * @custom:event Emit ReceivePayloadFailed if call fails\n     */\n    function _blockingLzReceive(\n        uint16 srcChainId_,\n        bytes memory srcAddress_,\n        uint64 nonce_,\n        bytes memory payload_\n    ) internal virtual override {\n        require(srcChainId_ == srcChainId, \"OmnichainGovernanceExecutor::_blockingLzReceive: invalid source chain id\");\n        bytes32 hashedPayload = keccak256(payload_);\n        bytes memory callData = abi.encodeCall(this.nonblockingLzReceive, (srcChainId_, srcAddress_, nonce_, payload_));\n\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(gasleft() - 30000, 150, callData);\n        // try-catch all errors/exceptions\n        if (!success) {\n            failedMessages[srcChainId_][srcAddress_][nonce_] = hashedPayload;\n            emit ReceivePayloadFailed(srcChainId_, srcAddress_, nonce_, reason); // Retrieve payload from the src side tx if needed to clear\n        }\n    }\n\n    /**\n     * @notice Process non blocking LayerZero receive request\n     * @param payload_ Encoded payload containing proposal information\n     * @custom:event Emit ProposalReceived\n     */\n    function _nonblockingLzReceive(\n        uint16,\n        bytes memory,\n        uint64,\n        bytes memory payload_\n    ) internal virtual override whenNotPaused {\n        (bytes memory payload, uint256 pId) = abi.decode(payload_, (bytes, uint256));\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas,\n            uint8 pType\n        ) = abi.decode(payload, (address[], uint256[], string[], bytes[], uint8));\n        require(proposals[pId].id == 0, \"OmnichainGovernanceExecutor::_nonblockingLzReceive: duplicate proposal\");\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"OmnichainGovernanceExecutor::_nonblockingLzReceive: proposal function information arity mismatch\"\n        );\n        require(\n            pType < uint8(type(ProposalType).max) + 1,\n            \"OmnichainGovernanceExecutor::_nonblockingLzReceive: invalid proposal type\"\n        );\n        _isEligibleToReceive(targets.length);\n\n        Proposal memory newProposal = Proposal({\n            id: pId,\n            eta: 0,\n            targets: targets,\n            values: values,\n            signatures: signatures,\n            calldatas: calldatas,\n            canceled: false,\n            executed: false,\n            proposalType: pType\n        });\n\n        proposals[pId] = newProposal;\n        lastProposalReceived = pId;\n\n        emit ProposalReceived(newProposal.id, targets, values, signatures, calldatas, pType);\n        _queue(pId);\n    }\n\n    /**\n     * @notice Queue proposal for execution\n     * @param proposalId_ Proposal to be queued\n     * @custom:event Emit ProposalQueued with proposal id and eta\n     */\n    function _queue(uint256 proposalId_) internal {\n        Proposal storage proposal = proposals[proposalId_];\n        uint256 eta = block.timestamp + proposalTimelocks[proposal.proposalType].delay();\n\n        proposal.eta = eta;\n        queued[proposalId_] = true;\n        uint8 proposalType = proposal.proposalType;\n        uint256 length = proposal.targets.length;\n        emit ProposalQueued(proposalId_, eta);\n\n        for (uint256 i; i < length; ++i) {\n            _queueOrRevertInternal(\n                proposal.targets[i],\n                proposal.values[i],\n                proposal.signatures[i],\n                proposal.calldatas[i],\n                eta,\n                proposalType\n            );\n        }\n    }\n\n    /**\n     * @notice Check for unique proposal\n     * @param target_ Address of the contract with the method to be called\n     * @param value_ Native token amount sent with the transaction\n     * @param signature_ Signature of the function to be called\n     * @param data_ Arguments to be passed to the function when called\n     * @param eta_ Timestamp after which the transaction can be executed\n     * @param proposalType_ Type of proposal\n     */\n    function _queueOrRevertInternal(\n        address target_,\n        uint256 value_,\n        string memory signature_,\n        bytes memory data_,\n        uint256 eta_,\n        uint8 proposalType_\n    ) internal {\n        require(\n            !proposalTimelocks[proposalType_].queuedTransactions(\n                keccak256(abi.encode(target_, value_, signature_, data_, eta_))\n            ),\n            \"OmnichainGovernanceExecutor::queueOrRevertInternal: identical proposal action already queued at eta\"\n        );\n\n        proposalTimelocks[proposalType_].queueTransaction(target_, value_, signature_, data_, eta_);\n    }\n}\n"
    },
    "contracts/Cross-chain/OmnichainProposalSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.25;\n\nimport { ReentrancyGuard } from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport { ILayerZeroEndpoint } from \"@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroEndpoint.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\nimport { BaseOmnichainControllerSrc } from \"./BaseOmnichainControllerSrc.sol\";\n\n/**\n * @title OmnichainProposalSender\n * @author Venus\n * @notice OmnichainProposalSender contract builds upon the functionality of its parent contract , BaseOmnichainControllerSrc\n * It sends a proposal's data to remote chains for execution after the proposal passes on the main chain\n * when used with GovernorBravo, the owner of this contract must be set to the Timelock contract\n * @custom:security-contact https://github.com/VenusProtocol/governance-contracts#discussion\n */\n\ncontract OmnichainProposalSender is ReentrancyGuard, BaseOmnichainControllerSrc {\n    /**\n     * @notice Stores the total number of remote proposals\n     */\n    uint256 public proposalCount;\n\n    /**\n     * @notice Execution hashes of failed messages\n     * @dev [proposalId] -> [executionHash]\n     */\n    mapping(uint256 => bytes32) public storedExecutionHashes;\n\n    /**\n     * @notice LayerZero endpoint for sending messages to remote chains\n     */\n    ILayerZeroEndpoint public immutable LZ_ENDPOINT;\n\n    /**\n     * @notice Specifies the allowed path for sending messages (remote chainId => remote app address + local app address)\n     */\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n\n    /**\n     * @notice Emitted when a remote message receiver is set for the remote chain\n     */\n    event SetTrustedRemoteAddress(uint16 indexed remoteChainId, bytes oldRemoteAddress, bytes newRemoteAddress);\n\n    /**\n     * @notice Event emitted when trusted remote sets to empty\n     */\n    event TrustedRemoteRemoved(uint16 indexed chainId);\n\n    /**\n     * @notice Emitted when a proposal execution request is sent to the remote chain\n     */\n    event ExecuteRemoteProposal(uint16 indexed remoteChainId, uint256 proposalId, bytes payload);\n\n    /**\n     * @notice Emitted when a previously failed message is successfully sent to the remote chain\n     */\n    event ClearPayload(uint256 indexed proposalId, bytes32 executionHash);\n\n    /**\n     * @notice Emitted when an execution hash of a failed message is saved\n     */\n    event StorePayload(\n        uint256 indexed proposalId,\n        uint16 indexed remoteChainId,\n        bytes payload,\n        bytes adapterParams,\n        uint256 value,\n        bytes reason\n    );\n    /**\n     * @notice Emitted while fallback withdraw\n     */\n    event FallbackWithdraw(address indexed receiver, uint256 value);\n\n    constructor(\n        ILayerZeroEndpoint lzEndpoint_,\n        address accessControlManager_\n    ) BaseOmnichainControllerSrc(accessControlManager_) {\n        ensureNonzeroAddress(address(lzEndpoint_));\n        LZ_ENDPOINT = lzEndpoint_;\n    }\n\n    /**\n     * @notice Estimates LayerZero fees for cross-chain message delivery to the remote chain\n     * @dev The estimated fees are the minimum required; it's recommended to increase the fees amount when sending a message. The unused amount will be refunded\n     * @param remoteChainId_ The LayerZero id of a remote chain\n     * @param payload_ The payload to be sent to the remote chain. It's computed as follows:\n     * payload = abi.encode(abi.encode(targets, values, signatures, calldatas, proposalType), pId)\n     * @param useZro_ Bool that indicates whether to pay in ZRO tokens or not\n     * @param adapterParams_ The params used to specify the custom amount of gas required for the execution on the destination\n     * @return nativeFee The amount of fee in the native gas token (e.g. ETH)\n     * @return zroFee The amount of fee in ZRO token\n     */\n    function estimateFees(\n        uint16 remoteChainId_,\n        bytes calldata payload_,\n        bool useZro_,\n        bytes calldata adapterParams_\n    ) external view returns (uint256, uint256) {\n        return LZ_ENDPOINT.estimateFees(remoteChainId_, address(this), payload_, useZro_, adapterParams_);\n    }\n\n    /**\n     * @notice Remove trusted remote from storage\n     * @param remoteChainId_ The chain's id corresponds to setting the trusted remote to empty\n     * @custom:access Controlled by Access Control Manager\n     * @custom:event Emit TrustedRemoteRemoved with remote chain id\n     */\n    function removeTrustedRemote(uint16 remoteChainId_) external {\n        _ensureAllowed(\"removeTrustedRemote(uint16)\");\n        require(trustedRemoteLookup[remoteChainId_].length != 0, \"OmnichainProposalSender: trusted remote not found\");\n        delete trustedRemoteLookup[remoteChainId_];\n        emit TrustedRemoteRemoved(remoteChainId_);\n    }\n\n    /**\n     * @notice Sends a message to execute a remote proposal\n     * @dev Stores the hash of the execution parameters if sending fails (e.g., due to insufficient fees)\n     * @param remoteChainId_ The LayerZero id of the remote chain\n     * @param payload_ The payload to be sent to the remote chain\n     * It's computed as follows: payload = abi.encode(targets, values, signatures, calldatas, proposalType)\n     * @param adapterParams_ The params used to specify the custom amount of gas required for the execution on the destination\n     * @param zroPaymentAddress_ The address of the ZRO token holder who would pay for the transaction. This must be either address(this) or tx.origin\n     * @custom:event Emits ExecuteRemoteProposal with remote chain id, proposal ID and payload on success\n     * @custom:event Emits StorePayload with last stored payload proposal ID ,remote chain id , payload, adapter params , values and reason for failure\n     * @custom:access Controlled by Access Control Manager\n     */\n    function execute(\n        uint16 remoteChainId_,\n        bytes calldata payload_,\n        bytes calldata adapterParams_,\n        address zroPaymentAddress_\n    ) external payable whenNotPaused {\n        _ensureAllowed(\"execute(uint16,bytes,bytes,address)\");\n\n        // A zero value will result in a failed message; therefore, a positive value is required to send a message across the chain.\n        require(msg.value > 0, \"OmnichainProposalSender: value cannot be zero\");\n        require(payload_.length != 0, \"OmnichainProposalSender: empty payload\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[remoteChainId_];\n        require(trustedRemote.length != 0, \"OmnichainProposalSender: destination chain is not a trusted source\");\n        _validateProposal(remoteChainId_, payload_);\n        uint256 _pId = ++proposalCount;\n        bytes memory payload = abi.encode(payload_, _pId);\n\n        try\n            LZ_ENDPOINT.send{ value: msg.value }(\n                remoteChainId_,\n                trustedRemote,\n                payload,\n                payable(msg.sender),\n                zroPaymentAddress_,\n                adapterParams_\n            )\n        {\n            emit ExecuteRemoteProposal(remoteChainId_, _pId, payload);\n        } catch (bytes memory reason) {\n            storedExecutionHashes[_pId] = keccak256(abi.encode(remoteChainId_, payload, adapterParams_, msg.value));\n            emit StorePayload(_pId, remoteChainId_, payload, adapterParams_, msg.value, reason);\n        }\n    }\n\n    /**\n     * @notice Resends a previously failed message\n     * @dev Allows providing more fees if needed. The extra fees will be refunded to the caller\n     * @param pId_ The proposal ID to identify a failed message\n     * @param remoteChainId_ The LayerZero id of the remote chain\n     * @param payload_ The payload to be sent to the remote chain\n     * It's computed as follows: payload = abi.encode(abi.encode(targets, values, signatures, calldatas, proposalType), pId)\n     * @param adapterParams_ The params used to specify the custom amount of gas required for the execution on the destination\n     * @param zroPaymentAddress_ The address of the ZRO token holder who would pay for the transaction.\n     * @param originalValue_ The msg.value passed when execute() function was called\n     * @custom:event Emits ClearPayload with proposal ID and hash\n     * @custom:access Controlled by Access Control Manager\n     */\n    function retryExecute(\n        uint256 pId_,\n        uint16 remoteChainId_,\n        bytes calldata payload_,\n        bytes calldata adapterParams_,\n        address zroPaymentAddress_,\n        uint256 originalValue_\n    ) external payable whenNotPaused nonReentrant {\n        _ensureAllowed(\"retryExecute(uint256,uint16,bytes,bytes,address,uint256)\");\n        bytes memory trustedRemote = trustedRemoteLookup[remoteChainId_];\n        require(trustedRemote.length != 0, \"OmnichainProposalSender: destination chain is not a trusted source\");\n        bytes32 hash = storedExecutionHashes[pId_];\n        require(hash != bytes32(0), \"OmnichainProposalSender: no stored payload\");\n        require(payload_.length != 0, \"OmnichainProposalSender: empty payload\");\n        (bytes memory payload, ) = abi.decode(payload_, (bytes, uint256));\n        _validateProposal(remoteChainId_, payload);\n\n        require(\n            keccak256(abi.encode(remoteChainId_, payload_, adapterParams_, originalValue_)) == hash,\n            \"OmnichainProposalSender: invalid execution params\"\n        );\n\n        delete storedExecutionHashes[pId_];\n\n        emit ClearPayload(pId_, hash);\n\n        LZ_ENDPOINT.send{ value: originalValue_ + msg.value }(\n            remoteChainId_,\n            trustedRemote,\n            payload_,\n            payable(msg.sender),\n            zroPaymentAddress_,\n            adapterParams_\n        );\n    }\n\n    /**\n     * @notice Clear previously failed message\n     * @param to_ Address of the receiver\n     * @param pId_ The proposal ID to identify a failed message\n     * @param remoteChainId_ The LayerZero id of the remote chain\n     * @param payload_ The payload to be sent to the remote chain\n     * It's computed as follows: payload = abi.encode(abi.encode(targets, values, signatures, calldatas, proposalType), pId)\n     * @param adapterParams_ The params used to specify the custom amount of gas required for the execution on the destination\n     * @param originalValue_ The msg.value passed when execute() function was called\n     * @custom:access Only owner\n     * @custom:event Emits ClearPayload with proposal ID and hash\n     * @custom:event Emits FallbackWithdraw with receiver and amount\n     */\n    function fallbackWithdraw(\n        address to_,\n        uint256 pId_,\n        uint16 remoteChainId_,\n        bytes calldata payload_,\n        bytes calldata adapterParams_,\n        uint256 originalValue_\n    ) external onlyOwner nonReentrant {\n        ensureNonzeroAddress(to_);\n        require(originalValue_ > 0, \"OmnichainProposalSender: invalid native amount\");\n        require(payload_.length != 0, \"OmnichainProposalSender: empty payload\");\n\n        bytes32 hash = storedExecutionHashes[pId_];\n        require(hash != bytes32(0), \"OmnichainProposalSender: no stored payload\");\n\n        bytes memory execution = abi.encode(remoteChainId_, payload_, adapterParams_, originalValue_);\n        require(keccak256(execution) == hash, \"OmnichainProposalSender: invalid execution params\");\n\n        delete storedExecutionHashes[pId_];\n\n        emit FallbackWithdraw(to_, originalValue_);\n        emit ClearPayload(pId_, hash);\n\n        // Transfer the native to the `to_` address\n        (bool sent, ) = to_.call{ value: originalValue_ }(\"\");\n        require(sent, \"Call failed\");\n    }\n\n    /**\n     * @notice Sets the remote message receiver address\n     * @param remoteChainId_ The LayerZero id of a remote chain\n     * @param newRemoteAddress_ The address of the contract on the remote chain to receive messages sent by this contract\n     * @custom:access Controlled by AccessControlManager\n     * @custom:event Emits SetTrustedRemoteAddress with remote chain Id and remote address\n     */\n    function setTrustedRemoteAddress(uint16 remoteChainId_, bytes calldata newRemoteAddress_) external {\n        _ensureAllowed(\"setTrustedRemoteAddress(uint16,bytes)\");\n        require(remoteChainId_ != 0, \"OmnichainProposalSender: chainId must not be zero\");\n        ensureNonzeroAddress(address(uint160(bytes20(newRemoteAddress_))));\n        require(newRemoteAddress_.length == 20, \"OmnichainProposalSender: remote address must be 20 bytes long\");\n        bytes memory oldRemoteAddress = trustedRemoteLookup[remoteChainId_];\n        trustedRemoteLookup[remoteChainId_] = abi.encodePacked(newRemoteAddress_, address(this));\n        emit SetTrustedRemoteAddress(remoteChainId_, oldRemoteAddress, trustedRemoteLookup[remoteChainId_]);\n    }\n\n    /**\n     * @notice Sets the configuration of the LayerZero messaging library of the specified version\n     * @param version_ Messaging library version\n     * @param chainId_ The LayerZero chainId for the pending config change\n     * @param configType_ The type of configuration. Every messaging library has its own convention\n     * @param config_ The configuration in bytes. It can encode arbitrary content\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setConfig(uint16 version_, uint16 chainId_, uint256 configType_, bytes calldata config_) external {\n        _ensureAllowed(\"setConfig(uint16,uint16,uint256,bytes)\");\n        LZ_ENDPOINT.setConfig(version_, chainId_, configType_, config_);\n    }\n\n    /**\n     * @notice Sets the configuration of the LayerZero messaging library of the specified version\n     * @param version_ New messaging library version\n     * @custom:access Controlled by AccessControlManager\n     */\n    function setSendVersion(uint16 version_) external {\n        _ensureAllowed(\"setSendVersion(uint16)\");\n        LZ_ENDPOINT.setSendVersion(version_);\n    }\n\n    /**\n     * @notice Gets the configuration of the LayerZero messaging library of the specified version\n     * @param version_ Messaging library version\n     * @param chainId_ The LayerZero chainId\n     * @param configType_ Type of configuration. Every messaging library has its own convention\n     */\n    function getConfig(uint16 version_, uint16 chainId_, uint256 configType_) external view returns (bytes memory) {\n        return LZ_ENDPOINT.getConfig(version_, chainId_, address(this), configType_);\n    }\n\n    function _validateProposal(uint16 remoteChainId_, bytes memory payload_) internal {\n        (\n            address[] memory targets,\n            uint256[] memory values,\n            string[] memory signatures,\n            bytes[] memory calldatas,\n\n        ) = abi.decode(payload_, (address[], uint[], string[], bytes[], uint8));\n        require(\n            targets.length == values.length &&\n                targets.length == signatures.length &&\n                targets.length == calldatas.length,\n            \"OmnichainProposalSender: proposal function information arity mismatch\"\n        );\n        _isEligibleToSend(remoteChainId_, targets.length);\n    }\n}\n"
    },
    "contracts/Governance/AccessControlledV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\";\n\nimport \"./IAccessControlManagerV8.sol\";\n\n/**\n * @title AccessControlledV8\n * @author Venus\n * @notice This contract is helper between access control manager and actual contract. This contract further inherited by other contract (using solidity 0.8.13)\n * to integrate access controlled mechanism. It provides initialise methods and verifying access methods.\n */\nabstract contract AccessControlledV8 is Initializable, Ownable2StepUpgradeable {\n    /// @notice Access control manager contract\n    IAccessControlManagerV8 private _accessControlManager;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n\n    /// @notice Emitted when access control manager contract address is changed\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\n\n    /// @notice Thrown when the action is prohibited by AccessControlManager\n    error Unauthorized(address sender, address calledContract, string methodSignature);\n\n    function __AccessControlled_init(address accessControlManager_) internal onlyInitializing {\n        __Ownable2Step_init();\n        __AccessControlled_init_unchained(accessControlManager_);\n    }\n\n    function __AccessControlled_init_unchained(address accessControlManager_) internal onlyInitializing {\n        _setAccessControlManager(accessControlManager_);\n    }\n\n    /**\n     * @notice Sets the address of AccessControlManager\n     * @dev Admin function to set address of AccessControlManager\n     * @param accessControlManager_ The new address of the AccessControlManager\n     * @custom:event Emits NewAccessControlManager event\n     * @custom:access Only Governance\n     */\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\n        _setAccessControlManager(accessControlManager_);\n    }\n\n    /**\n     * @notice Returns the address of the access control manager contract\n     */\n    function accessControlManager() external view returns (IAccessControlManagerV8) {\n        return _accessControlManager;\n    }\n\n    /**\n     * @dev Internal function to set address of AccessControlManager\n     * @param accessControlManager_ The new address of the AccessControlManager\n     */\n    function _setAccessControlManager(address accessControlManager_) internal {\n        require(address(accessControlManager_) != address(0), \"invalid acess control manager address\");\n        address oldAccessControlManager = address(_accessControlManager);\n        _accessControlManager = IAccessControlManagerV8(accessControlManager_);\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\n    }\n\n    /**\n     * @notice Reverts if the call is not allowed by AccessControlManager\n     * @param signature Method signature\n     */\n    function _checkAccessAllowed(string memory signature) internal view {\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\n\n        if (!isAllowedToCall) {\n            revert Unauthorized(msg.sender, address(this), signature);\n        }\n    }\n}\n"
    },
    "contracts/Governance/AccessControlManager.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\nimport \"./IAccessControlManagerV8.sol\";\n\n/**\n * @title AccessControlManager\n * @author Venus\n * @dev This contract is a wrapper of OpenZeppelin AccessControl extending it in a way to standartize access control within Venus Smart Contract Ecosystem.\n * @notice Access control plays a crucial role in the Venus governance model. It is used to restrict functions so that they can only be called from one\n * account or list of accounts (EOA or Contract Accounts).\n *\n * The implementation of `AccessControlManager`(https://github.com/VenusProtocol/governance-contracts/blob/main/contracts/Governance/AccessControlManager.sol)\n * inherits the [Open Zeppelin AccessControl](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/AccessControl.sol)\n * contract as a base for role management logic. There are two role types: admin and granular permissions.\n * \n * ## Granular Roles\n * \n * Granular roles are built by hashing the contract address and its function signature. For example, given contract `Foo` with function `Foo.bar()` which\n * is guarded by ACM, calling `giveRolePermission` for account B do the following:\n * \n * 1. Compute `keccak256(contractFooAddress,functionSignatureBar)`\n * 1. Add the computed role to the roles of account B\n * 1. Account B now can call `ContractFoo.bar()`\n * \n * ## Admin Roles\n * \n * Admin roles allow for an address to call a function signature on any contract guarded by the `AccessControlManager`. This is particularly useful for\n * contracts created by factories.\n * \n * For Admin roles a null address is hashed in place of the contract address (`keccak256(0x0000000000000000000000000000000000000000,functionSignatureBar)`.\n * \n * In the previous example, giving account B the admin role, account B will have permissions to call the `bar()` function on any contract that is guarded by\n * ACM, not only contract A.\n * \n * ## Protocol Integration\n * \n * All restricted functions in Venus Protocol use a hook to ACM in order to check if the caller has the right permission to call the guarded function.\n * `AccessControlledV5` and `AccessControlledV8` abstract contract makes this integration easier. They call ACM's external method\n * `isAllowedToCall(address caller, string functionSig)`. Here is an example of how `setCollateralFactor` function in `Comptroller` is integrated with ACM:\n\n```\n    contract Comptroller is [...] AccessControlledV8 {\n        [...]\n        function setCollateralFactor(VToken vToken, uint256 newCollateralFactorMantissa, uint256 newLiquidationThresholdMantissa) external {\n            _checkAccessAllowed(\"setCollateralFactor(address,uint256,uint256)\");\n            [...]\n        }\n    }\n```\n */\ncontract AccessControlManager is AccessControl, IAccessControlManagerV8 {\n    /// @notice Emitted when an account is given a permission to a certain contract function\n    /// @dev If contract address is 0x000..0 this means that the account is a default admin of this function and\n    /// can call any contract function with this signature\n    event PermissionGranted(address account, address contractAddress, string functionSig);\n\n    /// @notice Emitted when an account is revoked a permission to a certain contract function\n    event PermissionRevoked(address account, address contractAddress, string functionSig);\n\n    constructor() {\n        // Grant the contract deployer the default admin role: it will be able\n        // to grant and revoke any roles\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\n    }\n\n    /**\n     * @notice Gives a function call permission to one single account\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\n     * @param contractAddress address of contract for which call permissions will be granted\n     * @dev if contractAddress is zero address, the account can access the specified function\n     *      on **any** contract managed by this ACL\n     * @param functionSig signature e.g. \"functionName(uint256,bool)\"\n     * @param accountToPermit account that will be given access to the contract function\n     * @custom:event Emits a {RoleGranted} and {PermissionGranted} events.\n     */\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) public {\n        bytes32 role = keccak256(abi.encodePacked(contractAddress, functionSig));\n        grantRole(role, accountToPermit);\n        emit PermissionGranted(accountToPermit, contractAddress, functionSig);\n    }\n\n    /**\n     * @notice Revokes an account's permission to a particular function call\n     * @dev this function can be called only from Role Admin or DEFAULT_ADMIN_ROLE\n     * \t\tMay emit a {RoleRevoked} event.\n     * @param contractAddress address of contract for which call permissions will be revoked\n     * @param functionSig signature e.g. \"functionName(uint256,bool)\"\n     * @custom:event Emits {RoleRevoked} and {PermissionRevoked} events.\n     */\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) public {\n        bytes32 role = keccak256(abi.encodePacked(contractAddress, functionSig));\n        revokeRole(role, accountToRevoke);\n        emit PermissionRevoked(accountToRevoke, contractAddress, functionSig);\n    }\n\n    /**\n     * @notice Verifies if the given account can call a contract's guarded function\n     * @dev Since restricted contracts using this function as a permission hook, we can get contracts address with msg.sender\n     * @param account for which call permissions will be checked\n     * @param functionSig restricted function signature e.g. \"functionName(uint256,bool)\"\n     * @return false if the user account cannot call the particular contract function\n     *\n     */\n    function isAllowedToCall(address account, string calldata functionSig) public view returns (bool) {\n        bytes32 role = keccak256(abi.encodePacked(msg.sender, functionSig));\n\n        if (hasRole(role, account)) {\n            return true;\n        } else {\n            role = keccak256(abi.encodePacked(address(0), functionSig));\n            return hasRole(role, account);\n        }\n    }\n\n    /**\n     * @notice Verifies if the given account can call a contract's guarded function\n     * @dev This function is used as a view function to check permissions rather than contract hook for access restriction check.\n     * @param account for which call permissions will be checked against\n     * @param contractAddress address of the restricted contract\n     * @param functionSig signature of the restricted function e.g. \"functionName(uint256,bool)\"\n     * @return false if the user account cannot call the particular contract function\n     */\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) public view returns (bool) {\n        bytes32 role = keccak256(abi.encodePacked(contractAddress, functionSig));\n        return hasRole(role, account);\n    }\n}\n"
    },
    "contracts/Governance/IAccessControlManagerV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.25;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\n/**\n * @title IAccessControlManagerV8\n * @author Venus\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\n */\ninterface IAccessControlManagerV8 is IAccessControl {\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\n\n    function revokeCallPermission(\n        address contractAddress,\n        string calldata functionSig,\n        address accountToRevoke\n    ) external;\n\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\n\n    function hasPermission(\n        address account,\n        address contractAddress,\n        string calldata functionSig\n    ) external view returns (bool);\n}\n"
    },
    "contracts/Governance/TimelockV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\n/**\n * @title TimelockV8\n * @author Venus\n * @notice The Timelock contract using solidity V8.\n * This contract also differs from the original timelock because it has a virtual function to get minimum delays\n * and allow test deployments to override the value.\n */\ncontract TimelockV8 {\n    /// @notice Required period to execute a proposal transaction\n    uint256 private constant DEFAULT_GRACE_PERIOD = 14 days;\n\n    /// @notice Minimum amount of time a proposal transaction must be queued\n    uint256 private constant DEFAULT_MINIMUM_DELAY = 1 hours;\n\n    /// @notice Maximum amount of time a proposal transaction must be queued\n    uint256 private constant DEFAULT_MAXIMUM_DELAY = 30 days;\n\n    /// @notice Timelock admin authorized to queue and execute transactions\n    address public admin;\n\n    /// @notice Account proposed as the next admin\n    address public pendingAdmin;\n\n    /// @notice Period for a proposal transaction to be queued\n    uint256 public delay;\n\n    /// @notice Mapping of queued transactions\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    /// @notice Event emitted when a new admin is accepted\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Event emitted when a new admin is proposed\n    event NewPendingAdmin(address indexed newPendingAdmin);\n\n    /// @notice Event emitted when a new delay is proposed\n    event NewDelay(uint256 indexed oldDelay, uint256 indexed newDelay);\n\n    /// @notice Event emitted when a proposal transaction has been cancelled\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    /// @notice Event emitted when a proposal transaction has been executed\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    /// @notice Event emitted when a proposal transaction has been queued\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    constructor(address admin_, uint256 delay_) {\n        require(delay_ >= MINIMUM_DELAY(), \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY(), \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        ensureNonzeroAddress(admin_);\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    fallback() external payable {}\n\n    /**\n     * @notice Setter for the transaction queue delay\n     * @param delay_ The new delay period for the transaction queue\n     * @custom:access Sender must be Timelock itself\n     * @custom:event Emit NewDelay with old and new delay\n     */\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY(), \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY(), \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        emit NewDelay(delay, delay_);\n        delay = delay_;\n    }\n\n    /**\n     * @notice Return grace period\n     * @return The duration of the grace period, specified as a uint256 value.\n     */\n    function GRACE_PERIOD() public view virtual returns (uint256) {\n        return DEFAULT_GRACE_PERIOD;\n    }\n\n    /**\n     * @notice Return required minimum delay\n     * @return Minimum delay\n     */\n    function MINIMUM_DELAY() public view virtual returns (uint256) {\n        return DEFAULT_MINIMUM_DELAY;\n    }\n\n    /**\n     * @notice Return required maximum delay\n     * @return Maximum delay\n     */\n    function MAXIMUM_DELAY() public view virtual returns (uint256) {\n        return DEFAULT_MAXIMUM_DELAY;\n    }\n\n    /**\n     * @notice Method for accepting a proposed admin\n     * @custom:access Sender must be pending admin\n     * @custom:event Emit NewAdmin with old and new admin\n     */\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        emit NewAdmin(admin, msg.sender);\n        admin = msg.sender;\n        pendingAdmin = address(0);\n    }\n\n    /**\n     * @notice Method to propose a new admin authorized to call timelock functions. This should be the Governor Contract\n     * @param pendingAdmin_ Address of the proposed admin\n     * @custom:access Sender must be Timelock contract itself or admin\n     * @custom:event Emit NewPendingAdmin with new pending admin\n     */\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this) || msg.sender == admin,\n            \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n        );\n        ensureNonzeroAddress(pendingAdmin_);\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    /**\n     * @notice Called for each action when queuing a proposal\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature Signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @return Hash of the queued transaction\n     * @custom:access Sender must be admin\n     * @custom:event Emit QueueTransaction\n     */\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(\n            eta >= getBlockTimestamp() + delay,\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(!queuedTransactions[txHash], \"Timelock::queueTransaction: transaction already queued.\");\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    /**\n     * @notice Called to cancel a queued transaction\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature Signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @custom:access Sender must be admin\n     * @custom:event Emit CancelTransaction\n     */\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::cancelTransaction: transaction is not queued yet.\");\n        delete (queuedTransactions[txHash]);\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Called to execute a queued transaction\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature Signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @return Result of function call\n     * @custom:access Sender must be admin\n     * @custom:event Emit ExecuteTransaction\n     */\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) public returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta + GRACE_PERIOD(), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        delete (queuedTransactions[txHash]);\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    /**\n     * @notice Returns the current block timestamp\n     * @return The current block timestamp\n     */\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/ProxyAdmin.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/hardhat-deploy/solc_0.8/proxy/OptimizedTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport 'hardhat-deploy/solc_0.8/proxy/OptimizedTransparentUpgradeableProxy.sol';\n"
    },
    "contracts/test/MockAccessTest.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport \"../Governance/AccessControlledV8.sol\";\nimport \"@layerzerolabs/solidity-examples/contracts/lzApp/mocks/LZEndpointMock.sol\";\n\ncontract MockAccessTest is AccessControlledV8 {\n    /**\n     * @param accessControlManager Access control manager contract address\n     */\n    function initialize(address accessControlManager) external initializer {\n        __AccessControlled_init_unchained(accessControlManager);\n    }\n}\n"
    },
    "contracts/test/MockXVSVault.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\ncontract MockXVSVault {\n    /* solhint-disable no-unused-vars */\n    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {\n        /* solhint-enable no-unused-vars */\n        return 0;\n    }\n}\n"
    },
    "contracts/test/TestTimelockV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\nimport { TimelockV8 } from \"../Governance/TimelockV8.sol\";\n\ncontract TestTimelockV8 is TimelockV8 {\n    constructor(address admin_, uint256 delay_) public TimelockV8(admin_, delay_) {}\n\n    function GRACE_PERIOD() public view override returns (uint256) {\n        return 1 hours;\n    }\n\n    function MINIMUM_DELAY() public view override returns (uint256) {\n        return 1;\n    }\n\n    function MAXIMUM_DELAY() public view override returns (uint256) {\n        return 1 hours;\n    }\n}\n"
    },
    "contracts/Utils/ACMCommandsAggregator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { IAccessControlManagerV8 } from \"../Governance/IAccessControlManagerV8.sol\";\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\n/**\n * @title ACMCommandsAggregator\n * @author Venus\n * @notice This contract is a helper to aggregate multiple grant and revoke permissions in batches and execute them in one go.\n */\ncontract ACMCommandsAggregator {\n    /*\n     * @notice Struct to store permission details\n     */\n    struct Permission {\n        /*\n         * @notice Address of the contract\n         */\n        address contractAddress;\n        /*\n         * @notice Function signature\n         */\n        string functionSig;\n        /*\n         * @notice Address of the account\n         */\n        address account;\n    }\n\n    /**\n     * @notice Access control manager contract\n     */\n    IAccessControlManagerV8 public immutable ACM;\n\n    /*\n     * @notice 2D array to store grant permissions in batches\n     */\n    Permission[][] public grantPermissions;\n\n    /*\n     * @notice 2D array to store revoke permissions in batches\n     */\n    Permission[][] public revokePermissions;\n\n    /*\n     * @notice Event emitted when grant permissions are added\n     */\n    event GrantPermissionsAdded(uint256 index);\n\n    /*\n     * @notice Event emitted when revoke permissions are added\n     */\n    event RevokePermissionsAdded(uint256 index);\n\n    /*\n     * @notice Event emitted when grant permissions are executed\n     */\n    event GrantPermissionsExecuted(uint256 index);\n\n    /*\n     * @notice Event emitted when revoke permissions are executed\n     */\n    event RevokePermissionsExecuted(uint256 index);\n\n    /*\n     * @notice Error to be thrown when permissions are empty\n     */\n    error EmptyPermissions();\n\n    /*\n     * @notice Constructor to set the access control manager\n     * @param _acm Address of the access control manager\n     */\n    constructor(IAccessControlManagerV8 _acm) {\n        ensureNonzeroAddress(address(_acm));\n        ACM = _acm;\n    }\n\n    /*\n     * @notice Function to add grant permissions\n     * @param _permissions Array of permissions\n     * @custom:event Emits GrantPermissionsAdded event\n     */\n    function addGrantPermissions(Permission[] memory _permissions) external {\n        if (_permissions.length == 0) {\n            revert EmptyPermissions();\n        }\n\n        uint256 index = grantPermissions.length;\n        grantPermissions.push();\n\n        for (uint256 i; i < _permissions.length; ++i) {\n            grantPermissions[index].push(\n                Permission(_permissions[i].contractAddress, _permissions[i].functionSig, _permissions[i].account)\n            );\n        }\n\n        emit GrantPermissionsAdded(index);\n    }\n\n    /*\n     * @notice Function to add revoke permissions\n     * @param _permissions Array of permissions\n     * @custom:event Emits RevokePermissionsAdded event\n     */\n    function addRevokePermissions(Permission[] memory _permissions) external {\n        if (_permissions.length == 0) {\n            revert EmptyPermissions();\n        }\n\n        uint256 index = revokePermissions.length;\n        revokePermissions.push();\n\n        for (uint256 i; i < _permissions.length; ++i) {\n            revokePermissions[index].push(\n                Permission(_permissions[i].contractAddress, _permissions[i].functionSig, _permissions[i].account)\n            );\n        }\n\n        emit RevokePermissionsAdded(index);\n    }\n\n    /*\n     * @notice Function to execute grant permissions\n     * @param index Index of the permissions array\n     * @custom:event Emits GrantPermissionsExecuted event\n     */\n    function executeGrantPermissions(uint256 index) external {\n        uint256 length = grantPermissions[index].length;\n        for (uint256 i; i < length; ++i) {\n            Permission memory permission = grantPermissions[index][i];\n            ACM.giveCallPermission(permission.contractAddress, permission.functionSig, permission.account);\n        }\n\n        emit GrantPermissionsExecuted(index);\n    }\n\n    /*\n     * @notice Function to execute revoke permissions\n     * @param index Index of the permissions array\n     * @custom:event Emits RevokePermissionsExecuted event\n     */\n    function executeRevokePermissions(uint256 index) external {\n        uint256 length = revokePermissions[index].length;\n        for (uint256 i; i < length; ++i) {\n            Permission memory permission = revokePermissions[index][i];\n            ACM.revokeCallPermission(permission.contractAddress, permission.functionSig, permission.account);\n        }\n\n        emit RevokePermissionsExecuted(index);\n    }\n}\n"
    },
    "contracts/Voting/DataWarehouse.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {IDataWarehouse} from './IDataWarehouse.sol';\nimport {StateProofVerifier} from './libs/StateProofVerifier.sol';\nimport {RLPReader} from './libs/RLPReader.sol';\nimport {Errors} from './libraries/Errors.sol';\n\n/**\n * @title DataWarehouse\n * @author BGD Labs\n * @notice This contract stores account state roots and allows proving against them\n */\ncontract DataWarehouse is IDataWarehouse {\n  using RLPReader for bytes;\n  using RLPReader for RLPReader.RLPItem;\n\n  // account address => (block hash => Account state root hash)\n  mapping(address => mapping(bytes32 => bytes32)) internal _storageRoots;\n\n  // account address => (block hash => (slot => slot value))\n  mapping(address => mapping(bytes32 => mapping(bytes32 => uint256)))\n    internal _slotsRegistered;\n\n  /// @inheritdoc IDataWarehouse\n  function getStorageRoots(\n    address account,\n    bytes32 blockHash\n  ) external view returns (bytes32) {\n    return _storageRoots[account][blockHash];\n  }\n\n  /// @inheritdoc IDataWarehouse\n  function getRegisteredSlot(\n    bytes32 blockHash,\n    address account,\n    bytes32 slot\n  ) external view returns (uint256) {\n    return _slotsRegistered[account][blockHash][slot];\n  }\n\n  /// @inheritdoc IDataWarehouse\n  function processStorageRoot(\n    address account,\n    bytes32 blockHash,\n    bytes memory blockHeaderRLP,\n    bytes memory accountStateProofRLP\n  ) external returns (bytes32) {\n    StateProofVerifier.BlockHeader memory decodedHeader = StateProofVerifier\n      .verifyBlockHeader(blockHeaderRLP, blockHash);\n    // The path for an account in the state trie is the hash of its address\n    bytes32 proofPath = keccak256(abi.encodePacked(account));\n    StateProofVerifier.Account memory accountData = StateProofVerifier\n      .extractAccountFromProof(\n        proofPath,\n        decodedHeader.stateRootHash,\n        accountStateProofRLP.toRlpItem().toList()\n      );\n\n    _storageRoots[account][blockHash] = accountData.storageRoot;\n\n    emit StorageRootProcessed(msg.sender, account, blockHash);\n\n    return accountData.storageRoot;\n  }\n\n  /// @inheritdoc IDataWarehouse\n  function getStorage(\n    address account,\n    bytes32 blockHash,\n    bytes32 slot,\n    bytes memory storageProof\n  ) public view returns (StateProofVerifier.SlotValue memory) {\n    bytes32 root = _storageRoots[account][blockHash];\n    require(root != bytes32(0), Errors.UNPROCESSED_STORAGE_ROOT);\n\n    // The path for a storage value is the hash of its slot\n    bytes32 proofPath = keccak256(abi.encodePacked(slot));\n    StateProofVerifier.SlotValue memory slotData = StateProofVerifier\n      .extractSlotValueFromProof(\n        proofPath,\n        root,\n        storageProof.toRlpItem().toList()\n      );\n\n    return slotData;\n  }\n\n  /// @inheritdoc IDataWarehouse\n  function processStorageSlot(\n    address account,\n    bytes32 blockHash,\n    bytes32 slot,\n    bytes calldata storageProof\n  ) external {\n    StateProofVerifier.SlotValue memory storageSlot = getStorage(\n      account,\n      blockHash,\n      slot,\n      storageProof\n    );\n\n    _slotsRegistered[account][blockHash][slot] = storageSlot.value;\n\n    emit StorageSlotProcessed(\n      msg.sender,\n      account,\n      blockHash,\n      slot,\n      storageSlot.value\n    );\n  }\n}\n"
    },
    "contracts/Voting/IDataWarehouse.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.0;\n\nimport {StateProofVerifier} from './libs/StateProofVerifier.sol';\n\n/**\n * @title IDataWarehouse\n * @author BGD Labs\n * @notice interface containing the methods definitions of the DataWarehouse contract\n */\ninterface IDataWarehouse {\n  /**\n   * @notice event emitted when a storage root has been processed successfully\n   * @param caller address that called the processStorageRoot method\n   * @param account address where the root is generated\n   * @param blockHash hash of the block where the root was generated\n   */\n  event StorageRootProcessed(\n    address indexed caller,\n    address indexed account,\n    bytes32 indexed blockHash\n  );\n\n  /**\n   * @notice event emitted when a storage root has been processed successfully\n   * @param caller address that called the processStorageSlot method\n   * @param account address where the slot is processed\n   * @param blockHash hash of the block where the storage proof was generated\n   * @param slot storage location to search\n   * @param value storage information on the specified location\n   */\n  event StorageSlotProcessed(\n    address indexed caller,\n    address indexed account,\n    bytes32 indexed blockHash,\n    bytes32 slot,\n    uint256 value\n  );\n\n  /**\n   * @notice method to get the storage roots of an account (token) in a certain block hash\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @return state root hash of the account on the block hash specified\n   */\n  function getStorageRoots(\n    address account,\n    bytes32 blockHash\n  ) external view returns (bytes32);\n\n  /**\n   * @notice method to process the storage root from an account on a block hash.\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @param blockHeaderRLP rlp encoded block header. At same block where the block hash was taken\n   * @param accountStateProofRLP rlp encoded account state proof, taken in same block as block hash\n   * @return the storage root\n   */\n  function processStorageRoot(\n    address account,\n    bytes32 blockHash,\n    bytes memory blockHeaderRLP,\n    bytes memory accountStateProofRLP\n  ) external returns (bytes32);\n\n  /**\n   * @notice method to get the storage value at a certain slot and block hash for a certain address\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @param slot hash of the explicit storage placement where the value to get is found.\n   * @param storageProof generated proof containing the storage, at block hash\n   * @return an object containing the slot value at the specified storage slot\n   */\n  function getStorage(\n    address account,\n    bytes32 blockHash,\n    bytes32 slot,\n    bytes memory storageProof\n  ) external view returns (StateProofVerifier.SlotValue memory);\n\n  /**\n   * @notice method to register the storage value at a certain slot and block hash for a certain address\n   * @param account address of the token to get the storage roots from\n   * @param blockHash hash of the block from where the roots are generated\n   * @param slot hash of the explicit storage placement where the value to get is found.\n   * @param storageProof generated proof containing the storage, at block hash\n   */\n  function processStorageSlot(\n    address account,\n    bytes32 blockHash,\n    bytes32 slot,\n    bytes calldata storageProof\n  ) external;\n\n  /**\n   * @notice method to get the value from storage at a certain block hash, previously registered.\n   * @param blockHash hash of the block from where the roots are generated\n   * @param account address of the token to get the storage roots from\n   * @param slot hash of the explicit storage placement where the value to get is found.\n   * @return numeric slot value of the slot. The value must be decoded to get the actual stored information\n   */\n  function getRegisteredSlot(\n    bytes32 blockHash,\n    address account,\n    bytes32 slot\n  ) external view returns (uint256);\n}\n"
    },
    "contracts/Voting/IVotingMachineWithProofs.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDataWarehouse} from './IDataWarehouse.sol';\nimport {IVotingStrategy} from './IVotingStrategy.sol';\n\n/**\n * @title IVotingMachine\n * @author BGD Labs\n * @notice interface containing the objects, events and method definitions of the VotingMachine contract\n */\ninterface IVotingMachineWithProofs {\n  /**\n   * @notice Object containing the signature parameters to be able to vote as a representative\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   */\n  struct SignatureParams {\n    uint8 v;\n    bytes32 r;\n    bytes32 s;\n  }\n\n  /**\n   * @notice Object to use over submitVoteBySignature and in case of bridging for protect against wrong roots inclusion\n   * @param underlyingAsset address of the token on L1, used for voting\n   * @param slot base storage position where the balance on underlyingAsset contract resides on L1. (Normally position 0)\n   */\n  struct VotingAssetWithSlot {\n    address underlyingAsset;\n    uint128 slot;\n  }\n\n  /**\n   * @notice object containing the information of a bridged vote\n   * @param support indicates if vote is in favor or against the proposal\n   * @param votingAssetsWithSlots list of token addresses with storage slots, that the voter will use for voting\n   */\n  struct BridgedVote {\n    bool support;\n    VotingAssetWithSlot[] votingAssetsWithSlot;\n  }\n\n  /**\n   * @notice enum delimiting the possible states a proposal can have on the voting machine\n   * @dev ProposalState enum defines the state machine of a proposal being voted, so the order on which the state is\n          defined is important. Check logic correctness if new states are added / removed\n   */\n  enum ProposalState {\n    NotCreated,\n    Active,\n    Finished,\n    SentToGovernance\n  }\n\n  /**\n   * @notice Object with vote information\n   * @param support boolean indicating if the vote is in favor or against a proposal\n   * @param votingPower the power used for voting\n   */\n  struct Vote {\n    bool support;\n    uint248 votingPower;\n  }\n\n  /**\n   * @notice Object containing a proposal information\n   * @param id numeric identification of the proposal\n   * @param sentToGovernance boolean indication if the proposal results have been sent back to L1 governance\n   * @param startTime timestamp of the start of voting on the proposal\n   * @param endTime timestamp when the voting on the proposal finishes (startTime + votingDuration)\n   * @param votingClosedAndSentTimestamp timestamp indicating when the vote has been closed and sent to governance chain\n   * @param forVotes votes cast in favor of the proposal\n   * @param againstVotes votes cast against the proposal\n   * @param creationBlockNumber blockNumber from when the proposal has been created in votingMachine\n   * @param votingClosedAndSentBlockNumber block from when the vote has been closed and sent to governance chain\n   * @param votes mapping indication for every voter of the proposal the information of that vote\n   */\n  struct Proposal {\n    uint256 id;\n    bool sentToGovernance;\n    uint40 startTime;\n    uint40 endTime;\n    uint40 votingClosedAndSentTimestamp;\n    uint128 forVotes;\n    uint128 againstVotes;\n    uint256 creationBlockNumber;\n    uint256 votingClosedAndSentBlockNumber;\n    mapping(address => Vote) votes;\n  }\n\n  /**\n   * @notice Object containing a proposal information\n   * @param id numeric identification of the proposal\n   * @param sentToGovernance boolean indication if the proposal results have been sent back to L1 governance\n   * @param startTime timestamp of the start of voting on the proposal\n   * @param endTime timestamp when the voting on the proposal finishes (startTime + votingDuration)\n   * @param votingClosedAndSentTimestamp timestamp indicating when the vote has been closed and sent to governance chain\n   * @param forVotes votes cast in favor of the proposal\n   * @param againstVotes votes cast against the proposal\n   * @param creationBlockNumber blockNumber from when the proposal has been created in votingMachine\n   * @param votingClosedAndSentBlockNumber block from when the vote has been closed and sent back to governance chain\n   */\n  struct ProposalWithoutVotes {\n    uint256 id;\n    bool sentToGovernance;\n    uint40 startTime;\n    uint40 endTime;\n    uint40 votingClosedAndSentTimestamp;\n    uint128 forVotes;\n    uint128 againstVotes;\n    uint256 creationBlockNumber;\n    uint256 votingClosedAndSentBlockNumber;\n  }\n\n  /**\n   * @notice vote configuration passed from l1\n   * @param votingDuration duration in seconds of the vote for a proposal\n   * @param l1BlockHash hash of the block on L1 from the block when the proposal was activated for voting (sent to voting machine)\n            this block hash is used to delimit from when the voting power is accounted for voting\n   */\n  struct ProposalVoteConfiguration {\n    uint24 votingDuration;\n    bytes32 l1ProposalBlockHash;\n  }\n\n  /**\n   * @notice Object with the necessary information to process a vote\n   * @param underlyingAsset address of the token on L1, used for voting\n   * @param slot base storage position where the balance on underlyingAsset contract resides on L1. (Normally position 0)\n   * @param proof bytes of the generated proof on L1 with the slot information of underlying asset.\n   */\n  struct VotingBalanceProof {\n    address underlyingAsset;\n    uint128 slot;\n    bytes proof;\n  }\n\n  /**\n   * @notice emitted when a proposal is created\n   * @param proposalId numeric id of the created proposal\n   * @param l1BlockHash block hash from the block on l1 from when the proposal was activated for voting\n   * @param startTime timestamp when the proposal was created and ready for voting\n   * @param endTime timestamp of when the voting period ends. (startTime + votingDuration)\n   */\n  event ProposalVoteStarted(\n    uint256 indexed proposalId,\n    bytes32 indexed l1BlockHash,\n    uint256 startTime,\n    uint256 endTime\n  );\n\n  /**\n   * @notice emitted when the results of a vote on a proposal are sent to L1\n   * @param proposalId numeric id of the proposal which results are sent to L1\n   * @param forVotes votes cast in favor of proposal\n   * @param againstVotes votes cast against the proposal\n   */\n  event ProposalResultsSent(\n    uint256 indexed proposalId,\n    uint256 forVotes,\n    uint256 againstVotes\n  );\n\n  /**\n   * @notice emitted when a vote is registered\n   * @param proposalId Id of the proposal\n   * @param voter address of the voter\n   * @param support boolean, true = vote for, false = vote against\n   * @param votingPower Power of the voter/vote\n   */\n  event VoteEmitted(\n    uint256 indexed proposalId,\n    address indexed voter,\n    bool indexed support,\n    uint256 votingPower\n  );\n\n  /**\n   * @notice emitted when a voting configuration of a proposal gets received. Meaning that has been bridged successfully\n   * @param proposalId id of the proposal bridged to start the vote on\n   * @param blockHash hash of the block on L1 when the proposal was activated for voting\n   * @param votingDuration duration in seconds of the vote\n   * @param voteCreated boolean indicating if the vote has been created or not.\n   * @dev the vote will only be created automatically if when the configuration is bridged, all necessary roots\n          have been registered already.\n   */\n  event ProposalVoteConfigurationBridged(\n    uint256 indexed proposalId,\n    bytes32 indexed blockHash,\n    uint24 votingDuration,\n    bool indexed voteCreated\n  );\n\n  /**\n   * @notice method to get the representatives mapping slot in Governance contract\n   * @return representatives slot\n   */\n  function REPRESENTATIVES_SLOT() external view returns (uint256);\n\n  /**\n   * @notice method to get the Governance contract address\n   * @return Governance address\n   */\n  function GOVERNANCE() external view returns (address);\n\n  /**\n   * @notice method to get the voting asset with slot signature\n   * @return signature of the voting asset with slot method\n   */\n  function VOTING_ASSET_WITH_SLOT_RAW() external view returns (string memory);\n\n  /**\n   * @notice method to get the DataWarehouse contract\n   * @return DataWarehouse contract\n   */\n  function DATA_WAREHOUSE() external view returns (IDataWarehouse);\n\n  /**\n   * @notice method to get the VotingStrategy contract\n   * @return VotingStrategy contract\n   */\n  function VOTING_STRATEGY() external view returns (IVotingStrategy);\n\n  /**\n   * @notice Get the v4 compatible domain separator\n   * @dev Return cached value if chainId matches cache, otherwise recomputes separator\n   * @return The domain separator of the token at current chain\n   */\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  /**\n   * @notice method to get the vote submitted type hash for permits digest\n   * @return hash of vote submitted string\n   */\n  function VOTE_SUBMITTED_TYPEHASH() external view returns (bytes32);\n\n  /**\n   * @notice method to get the vote submitted by representative type hash for permits digest\n   * @return hash of vote submitted by representative string\n   */\n  function VOTE_SUBMITTED_BY_REPRESENTATIVE_TYPEHASH()\n    external\n    view\n    returns (bytes32);\n\n  /**\n   * @notice method to get the voting asset with slot type hash for permits digest\n   * @return hash of vote submitted string\n   */\n  function VOTING_ASSET_WITH_SLOT_TYPEHASH() external view returns (bytes32);\n\n  /**\n   * @notice method to get the contract name for permits digest\n   * @return contract name string\n   */\n  function NAME() external view returns (string memory);\n\n  /**\n   * @notice method to get a proposal information specified by its id\n   * @param proposalId id of the proposal to retrieve\n   * @return the proposal information without the users vote\n   */\n  function getProposalById(\n    uint256 proposalId\n  ) external view returns (ProposalWithoutVotes memory);\n\n  /**\n   * @notice method to get the state of a proposal specified by its id\n   * @param proposalId id of the proposal to retrieve the state of\n   * @return the state of the proposal\n   */\n  function getProposalState(\n    uint256 proposalId\n  ) external view returns (ProposalState);\n\n  /**\n   * @notice method to get the voting configuration of a proposal specified by its id\n   * @param proposalId id of the proposal to retrieve the voting configuration from\n   * @return the proposal vote configuration object\n   */\n  function getProposalVoteConfiguration(\n    uint256 proposalId\n  ) external view returns (ProposalVoteConfiguration memory);\n\n  /**\n  * @notice method to get a paginated list of proposalIds. The proposals are taken from a list of proposals that have\n            received vote configuration from governance chain\n  * @param skip number of proposal ids to skip. from latest in the list of proposal ids with voting configuration\n  * @param size length of proposal ids to ask for.\n  * @return list of proposal ids\n  * @dev This is mainly used to get a list of proposals that require automation in some step of the proposal live cycle.\n  */\n  function getProposalsVoteConfigurationIds(\n    uint256 skip,\n    uint256 size\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @notice method to get the vote set by a user on a proposal specified by its id\n   * @param user address of the user that voted\n   * @param proposalId id of the proposal to retrieve the vote from\n   * @return the vote (support and voting power) emitted\n   */\n  function getUserProposalVote(\n    address user,\n    uint256 proposalId\n  ) external view returns (Vote memory);\n\n  /**\n    * @notice method to start a vote on a proposal specified by its id.\n    * @param proposalId id of the proposal to start the vote on.\n    * @return the id of the proposal that had the vote started on.\n    * @dev this method can be called by anyone, requiring that the appropriate conditions are met.\n           basically that the proper roots have been registered.\n           It can also be called internally when the bridged message is received and the the required roots\n           have been registered\n    */\n  function startProposalVote(uint256 proposalId) external returns (uint256);\n\n  /**\n    * @notice method to cast a vote on a proposal specified by its id\n    * @param proposalId id of the proposal on which the vote will be cast\n    * @param support boolean indicating if the vote is in favor or against the proposal\n    * @param votingBalanceProofs list of objects containing the information necessary to vote using the tokens\n             allowed on the voting strategy.\n    * @dev A vote does not need to use all the tokens allowed, can be a subset\n    */\n  function submitVote(\n    uint256 proposalId,\n    bool support,\n    VotingBalanceProof[] calldata votingBalanceProofs\n  ) external;\n\n  /**\n   * @notice Function to register the vote of user that has voted offchain via signature\n   * @param proposalId id of the proposal\n   * @param voter the voter address\n   * @param support boolean, true = vote for, false = vote against\n   * @param votingBalanceProofs list of voting assets proofs\n   * @param v v part of the voter signature\n   * @param r r part of the voter signature\n   * @param s s part of the voter signature\n   */\n  function submitVoteBySignature(\n    uint256 proposalId,\n    address voter,\n    bool support,\n    VotingBalanceProof[] calldata votingBalanceProofs,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @notice method to close a vote on a proposal specified by its id and send the results back to governance\n   * @param proposalId id of the proposal to close the vote on and send the voting result to governance\n   * @dev This method will trigger the bridging flow\n   */\n  function closeAndSendVote(uint256 proposalId) external;\n\n  /**\n   * @notice Function to register the vote of user as its representative\n   * @param proposalId id of the proposal\n   * @param support boolean, true = vote for, false = vote against\n   * @param voter the voter address\n   * @param proofOfRepresentation proof that can validate that msg.sender is the voter representative\n   * @param votingBalanceProofs list of voting assets proofs\n   */\n  function submitVoteAsRepresentative(\n    uint256 proposalId,\n    bool support,\n    address voter,\n    bytes memory proofOfRepresentation,\n    VotingBalanceProof[] calldata votingBalanceProofs\n  ) external;\n\n  /**\n   * @notice Function to register the vote of user as its representative with a signed message\n   * @param proposalId id of the proposal\n   * @param voter the voter address\n   * @param proofOfRepresentation proof that can validate that msg.sender is the voter representative\n   * @param votingBalanceProofs list of voting assets proofs\n   * @param signatureParams object containing the necessary signature parameters\n   */\n  function submitVoteAsRepresentativeBySignature(\n    uint256 proposalId,\n    address voter,\n    address representative,\n    bool support,\n    bytes memory proofOfRepresentation,\n    VotingBalanceProof[] calldata votingBalanceProofs,\n    SignatureParams memory signatureParams\n  ) external;\n}\n"
    },
    "contracts/Voting/IVotingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDataWarehouse} from './IDataWarehouse.sol';\n\n/**\n * @title IVotingStrategy\n * @author BGD Labs\n * @notice interface containing the methods definitions of the VotingStrategy contract\n */\ninterface IVotingStrategy {\n  /**\n   * @notice method to get the DataWarehouse contract\n   * @return DataWarehouse contract\n   */\n  function DATA_WAREHOUSE() external view returns (IDataWarehouse);\n\n  /**\n   * @notice method to get the exchange rate precision. Taken from stkTokenV3 contract\n   * @return exchange rate precission\n   */\n  function STK_AAVE_SLASHING_EXCHANGE_RATE_PRECISION()\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @notice method to get the slot of the stkAave exchange rate in the stkAave contract\n   * @return stkAave exchange rate slot\n   */\n  function STK_AAVE_SLASHING_EXCHANGE_RATE_SLOT()\n    external\n    view\n    returns (uint256);\n\n  /**\n   * @notice method to get the power scale factor of the delegated balances\n   * @return power scale factor\n   */\n  function POWER_SCALE_FACTOR() external view returns (uint256);\n\n  /**\n   * @notice method to get the power of an asset\n   * @param asset address of the token to get the power\n   * @param storageSlot storage position of the balance mapping\n   * @param power balance of a determined asset to be used for the vote\n   * @param blockHash block hash of when we want to get the power. Optional parameter\n   * @return voting power of the specified asset\n   */\n  function getVotingPower(\n    address asset,\n    uint128 storageSlot,\n    uint256 power,\n    bytes32 blockHash\n  ) external view returns (uint256);\n\n  /**\n   * @notice method to check that the roots for all the tokens in the voting strategy have been registered. Including\n             the registry of the stkAave exchange rate slot\n   * @param blockHash hash of the block from where the roots have been registered.\n   */\n  function hasRequiredRoots(bytes32 blockHash) external view;\n}\n"
    },
    "contracts/Voting/libraries/Errors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Errors library\n * @author BGD Labs\n * @notice Defines the error messages emitted by the different contracts of the Aave Governance V3\n */\nlibrary Errors {\n  string public constant VOTING_PORTALS_COUNT_NOT_0 = '1'; // to be able to rescue voting portals count must be 0\n  string public constant AT_LEAST_ONE_PAYLOAD = '2'; // to create a proposal, it must have at least one payload\n  string public constant VOTING_PORTAL_NOT_APPROVED = '3'; // the voting portal used to vote on proposal must be approved\n  string public constant PROPOSITION_POWER_IS_TOO_LOW = '4'; // proposition power of proposal creator must be equal or higher than the specified threshold for the access level\n  string public constant PROPOSAL_NOT_IN_CREATED_STATE = '5'; // proposal should be in the CREATED state\n  string public constant PROPOSAL_NOT_IN_ACTIVE_STATE = '6'; // proposal must be in an ACTIVE state\n  string public constant PROPOSAL_NOT_IN_QUEUED_STATE = '7'; // proposal must be in a QUEUED state\n  string public constant VOTING_START_COOLDOWN_PERIOD_NOT_PASSED = '8'; // to activate a proposal vote, the cool down delay must pass\n  string public constant CALLER_NOT_A_VALID_VOTING_PORTAL = '9'; // only an allowed voting portal can queue a proposal\n  string public constant QUEUE_COOLDOWN_PERIOD_NOT_PASSED = '10'; // to execute a proposal a cooldown delay must pass\n  string public constant PROPOSAL_NOT_IN_THE_CORRECT_STATE = '11'; // proposal must be created but not executed yet to be able to be canceled\n  string public constant CALLER_NOT_GOVERNANCE = '12'; // caller must be governance\n  string public constant VOTER_ALREADY_VOTED_ON_PROPOSAL = '13'; // voter can only vote once per proposal using voting portal\n  string public constant WRONG_MESSAGE_ORIGIN = '14'; // received message must come from registered source address, chain id, CrossChainController\n  string public constant NO_VOTING_ASSETS = '15'; // Strategy must have voting assets\n  string public constant PROPOSAL_VOTE_ALREADY_CREATED = '16'; // vote on proposal can only be created once\n  string public constant INVALID_SIGNATURE = '17'; // submitted signature is not valid\n  string public constant PROPOSAL_VOTE_NOT_FINISHED = '18'; // proposal vote must be finished\n  string public constant PROPOSAL_VOTE_NOT_IN_ACTIVE_STATE = '19'; // proposal vote must be in active state\n  string public constant PROPOSAL_VOTE_ALREADY_EXISTS = '20'; // proposal vote already exists\n  string public constant VOTE_ONCE_FOR_ASSET = '21'; // an asset can only be used once per vote\n  string public constant USER_BALANCE_DOES_NOT_EXISTS = '22'; // to vote an user must have balance in the token the user is voting with\n  string public constant USER_VOTING_BALANCE_IS_ZERO = '23'; // to vote an user must have some balance between all the tokens selected for voting\n  string public constant MISSING_AAVE_ROOTS = '24'; // must have AAVE roots registered to use strategy\n  string public constant MISSING_STK_AAVE_ROOTS = '25'; // must have stkAAVE roots registered to use strategy\n  string public constant MISSING_STK_AAVE_SLASHING_EXCHANGE_RATE = '26'; // must have stkAAVE slashing exchange rate registered to use strategy\n  string public constant UNPROCESSED_STORAGE_ROOT = '27'; // root must be registered beforehand\n  string public constant NOT_ENOUGH_MSG_VALUE = '28'; // method was not called with enough value to execute the call\n  string public constant FAILED_ACTION_EXECUTION = '29'; // action failed to execute\n  string public constant SHOULD_BE_AT_LEAST_ONE_EXECUTOR = '30'; // at least one executor is needed\n  string public constant INVALID_EMPTY_TARGETS = '31'; // target of the payload execution must not be empty\n  string public constant EXECUTOR_WAS_NOT_SPECIFIED_FOR_REQUESTED_ACCESS_LEVEL =\n    '32'; // payload executor must be registered for the specified payload access level\n  string public constant PAYLOAD_NOT_IN_QUEUED_STATE = '33'; // payload must be en the queued state\n  string public constant TIMELOCK_NOT_FINISHED = '34'; // delay has not passed before execution can be called\n  string public constant PAYLOAD_NOT_IN_THE_CORRECT_STATE = '35'; // payload must be created but not executed yet to be able to be canceled\n  string public constant PAYLOAD_NOT_IN_CREATED_STATE = '36'; // payload must be in the created state\n  string public constant MISSING_A_AAVE_ROOTS = '37'; // must have aAAVE roots registered to use strategy\n  string public constant MISSING_PROPOSAL_BLOCK_HASH = '38'; // block hash for this proposal was not bridged before\n  string public constant PROPOSAL_VOTE_CONFIGURATION_ALREADY_BRIDGED = '39'; // configuration for this proposal bridged already\n  string public constant INVALID_VOTING_PORTAL_ADDRESS = '40'; // voting portal address can't be 0x0\n  string public constant INVALID_POWER_STRATEGY = '41'; // 0x0 is not valid as the power strategy\n  string public constant INVALID_EXECUTOR_ADDRESS = '42'; // executor address can't be 0x0\n  string public constant EXECUTOR_ALREADY_SET_IN_DIFFERENT_LEVEL = '43'; // executor address already being used as executor of a different level\n  string public constant INVALID_VOTING_DURATION = '44'; // voting duration can not be bigger than the time it takes to execute a proposal\n  string public constant VOTING_DURATION_NOT_PASSED = '45'; // at least votingDuration should have passed since voting started for a proposal to be queued\n  string public constant INVALID_PROPOSAL_ACCESS_LEVEL = '46'; // the bridged proposal access level does not correspond with the maximum access level required by the payload\n  string public constant PAYLOAD_NOT_CREATED_BEFORE_PROPOSAL = '47'; // payload must be created before proposal\n  string public constant INVALID_CROSS_CHAIN_CONTROLLER_ADDRESS = '48';\n  string public constant INVALID_MESSAGE_ORIGINATOR_ADDRESS = '49';\n  string public constant INVALID_ORIGIN_CHAIN_ID = '50';\n  string public constant INVALID_ACTION_TARGET = '51';\n  string public constant INVALID_ACTION_ACCESS_LEVEL = '52';\n  string public constant INVALID_EXECUTOR_ACCESS_LEVEL = '53';\n  string public constant INVALID_VOTING_PORTAL_CROSS_CHAIN_CONTROLLER = '54';\n  string public constant INVALID_VOTING_PORTAL_VOTING_MACHINE = '55';\n  string public constant INVALID_VOTING_PORTAL_GOVERNANCE = '56';\n  string public constant INVALID_VOTING_MACHINE_CHAIN_ID = '57';\n  string public constant G_INVALID_CROSS_CHAIN_CONTROLLER_ADDRESS = '58';\n  string public constant G_INVALID_IPFS_HASH = '59';\n  string public constant G_INVALID_PAYLOAD_ACCESS_LEVEL = '60';\n  string public constant G_INVALID_PAYLOADS_CONTROLLER = '61';\n  string public constant G_INVALID_PAYLOAD_CHAIN = '62';\n  string public constant POWER_STRATEGY_HAS_NO_TOKENS = '63'; // power strategy should at least have\n  string public constant INVALID_VOTING_CONFIG_ACCESS_LEVEL = '64';\n  string public constant VOTING_DURATION_TOO_SMALL = '65';\n  string public constant NO_BRIDGED_VOTING_ASSETS = '66';\n  string public constant INVALID_VOTER = '67';\n  string public constant INVALID_DATA_WAREHOUSE = '68';\n  string public constant INVALID_VOTING_MACHINE_CROSS_CHAIN_CONTROLLER = '69';\n  string public constant INVALID_L1_VOTING_PORTAL = '70';\n  string public constant INVALID_VOTING_PORTAL_CHAIN_ID = '71';\n  string public constant INVALID_VOTING_STRATEGY = '72';\n  string public constant INVALID_VOTE_CONFIGURATION_BLOCKHASH = '73';\n  string public constant INVALID_VOTE_CONFIGURATION_VOTING_DURATION = '74';\n  string public constant INVALID_GAS_LIMIT = '75';\n  string public constant INVALID_VOTING_CONFIGS = '76'; // a lvl2 voting configuration must be sent to initializer\n  string public constant INVALID_EXECUTOR_DELAY = '77';\n  string public constant REPEATED_STRATEGY_ASSET = '78';\n  string public constant EMPTY_ASSET_STORAGE_SLOTS = '79';\n  string public constant REPEATED_STRATEGY_ASSET_SLOT = '80';\n  string public constant INVALID_EXECUTION_TARGET = '81';\n  string public constant MISSING_VOTING_CONFIGURATIONS = '82'; // voting configurations for lvl1 and lvl2 must be included on initialization\n  string public constant INVALID_PROPOSITION_POWER = '83';\n  string public constant INVALID_YES_THRESHOLD = '84';\n  string public constant INVALID_YES_NO_DIFFERENTIAL = '85';\n  string public constant ETH_TRANSFER_FAILED = '86';\n  string public constant INVALID_INITIAL_VOTING_CONFIGS = '87'; // initial voting configurations can not be of the same level\n  string public constant INVALID_VOTING_PORTAL_ADDRESS_IN_VOTING_MACHINE = '88';\n  string public constant INVALID_VOTING_PORTAL_OWNER = '89';\n  string public constant CANCELLATION_FEE_REDEEM_FAILED = '90'; // cancellation fee was not able to be redeemed\n  string public constant INVALID_CANCELLATION_FEE_COLLECTOR = '91'; // collector can not be address 0\n  string public constant INVALID_CANCELLATION_FEE_SENT = '92'; // cancellation fee sent does not match the needed amount\n  string public constant CANCELLATION_FEE_ALREADY_REDEEMED = '93'; // cancellation fee already redeemed\n  string public constant INVALID_STATE_TO_REDEEM_CANCELLATION_FEE = '94'; // proposal state is not a valid state to redeem cancellation fee\n  string public constant MISSING_REPRESENTATION_ROOTS = '95'; // to represent a voter the representation roots need to be registered\n  string public constant CALLER_IS_NOT_VOTER_REPRESENTATIVE = '96'; // to represent a voter, caller must be the stored representative\n  string public constant VM_INVALID_GOVERNANCE_ADDRESS = '97'; // governance address can not be 0\n  string public constant ALL_DELEGATION_ACTIONS_FAILED = '98'; // all meta delegation actions failed on MetaDelegateHelper\n}\n"
    },
    "contracts/Voting/libraries/SlotUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nlibrary SlotUtils {\n  /**\n   * @notice method to calculate the slot hash of the a mapping indexed by account\n   * @param account address of the balance holder\n   * @param balanceMappingPosition base position of the storage slot of the balance on a token contract\n   * @return the slot hash\n   */\n  function getAccountSlotHash(\n    address account,\n    uint256 balanceMappingPosition\n  ) internal pure returns (bytes32) {\n    return\n      keccak256(\n        abi.encodePacked(\n          bytes32(uint256(uint160(account))),\n          balanceMappingPosition\n        )\n      );\n  }\n\n  /**\n   * @notice method to calculate the slot hash of the a mapping indexed by voter and chainId\n   * @param voter address of the voter\n   * @param chainId id of the chain of the votingMachine\n   * @param representativesMappingPosition base position of the storage slot of the representatives on governance contract\n   * @return the slot hash\n   * @dev mapping(address => mapping(uint256 => address))\n   */\n  function getRepresentativeSlotHash(\n    address voter,\n    uint256 chainId,\n    uint256 representativesMappingPosition\n  ) internal pure returns (bytes32) {\n    bytes32 voterMappingIndex = keccak256(\n      abi.encodePacked(\n        bytes32(uint256(uint160(voter))),\n        representativesMappingPosition\n      )\n    );\n\n    return\n      keccak256(abi.encodePacked(bytes32(chainId), uint256(voterMappingIndex)));\n  }\n}\n"
    },
    "contracts/Voting/libs/MerklePatriciaProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Copied from https://github.com/lidofinance/curve-merkle-oracle/blob/main/contracts/MerklePatriciaProofVerifier.sol\n */\npragma solidity ^0.8.0;\n\nimport {RLPReader} from './RLPReader.sol';\n\nlibrary MerklePatriciaProofVerifier {\n  using RLPReader for RLPReader.RLPItem;\n  using RLPReader for bytes;\n\n  /// @dev Validates a Merkle-Patricia-Trie proof.\n  ///      If the proof proves the inclusion of some key-value pair in the\n  ///      trie, the value is returned. Otherwise, i.e. if the proof proves\n  ///      the exclusion of a key from the trie, an empty byte array is\n  ///      returned.\n  /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\n  /// @param path is the key of the node whose inclusion/exclusion we are\n  ///        proving.\n  /// @param stack is the stack of MPT nodes (starting with the root) that\n  ///        need to be traversed during verification.\n  /// @return value whose inclusion is proved or an empty byte array for\n  ///         a proof of exclusion\n  function extractProofValue(\n    bytes32 rootHash,\n    bytes memory path,\n    RLPReader.RLPItem[] memory stack\n  ) internal pure returns (bytes memory value) {\n    bytes memory mptKey = _decodeNibbles(path, 0);\n    uint256 mptKeyOffset = 0;\n\n    bytes32 nodeHashHash;\n    RLPReader.RLPItem[] memory node;\n\n    RLPReader.RLPItem memory rlpValue;\n\n    if (stack.length == 0) {\n      // Root hash of empty Merkle-Patricia-Trie\n      require(\n        rootHash ==\n          0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\n      );\n      return new bytes(0);\n    }\n\n    // Traverse stack of nodes starting at root.\n    for (uint256 i = 0; i < stack.length; i++) {\n      // We use the fact that an rlp encoded list consists of some\n      // encoding of its length plus the concatenation of its\n      // *rlp-encoded* items.\n\n      // The root node is hashed with Keccak-256 ...\n      if (i == 0 && rootHash != stack[i].rlpBytesKeccak256()) {\n        revert();\n      }\n      // ... whereas all other nodes are hashed with the MPT\n      // hash function.\n      if (i != 0 && nodeHashHash != _mptHashHash(stack[i])) {\n        revert();\n      }\n      // We verified that stack[i] has the correct hash, so we\n      // may safely decode it.\n      node = stack[i].toList();\n\n      if (node.length == 2) {\n        // Extension or Leaf node\n\n        bool isLeaf;\n        bytes memory nodeKey;\n        (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\n\n        uint256 prefixLength = _sharedPrefixLength(\n          mptKeyOffset,\n          mptKey,\n          nodeKey\n        );\n        mptKeyOffset += prefixLength;\n\n        if (prefixLength < nodeKey.length) {\n          // Proof claims divergent extension or leaf. (Only\n          // relevant for proofs of exclusion.)\n          // An Extension/Leaf node is divergent iff it \"skips\" over\n          // the point at which a Branch node should have been had the\n          // excluded key been included in the trie.\n          // Example: Imagine a proof of exclusion for path [1, 4],\n          // where the current node is a Leaf node with\n          // path [1, 3, 3, 7]. For [1, 4] to be included, there\n          // should have been a Branch node at [1] with a child\n          // at 3 and a child at 4.\n\n          // Sanity check\n          if (i < stack.length - 1) {\n            // divergent node must come last in proof\n            revert();\n          }\n\n          return new bytes(0);\n        }\n\n        if (isLeaf) {\n          // Sanity check\n          if (i < stack.length - 1) {\n            // leaf node must come last in proof\n            revert();\n          }\n\n          if (mptKeyOffset < mptKey.length) {\n            return new bytes(0);\n          }\n\n          rlpValue = node[1];\n          return rlpValue.toBytes();\n        } else {\n          // extension\n          // Sanity check\n          if (i == stack.length - 1) {\n            // shouldn't be at last level\n            revert();\n          }\n\n          if (!node[1].isList()) {\n            // rlp(child) was at least 32 bytes. node[1] contains\n            // Keccak256(rlp(child)).\n            nodeHashHash = node[1].payloadKeccak256();\n          } else {\n            // rlp(child) was less than 32 bytes. node[1] contains\n            // rlp(child).\n            nodeHashHash = node[1].rlpBytesKeccak256();\n          }\n        }\n      } else if (node.length == 17) {\n        // Branch node\n\n        if (mptKeyOffset != mptKey.length) {\n          // we haven't consumed the entire path, so we need to look at a child\n          uint8 nibble = uint8(mptKey[mptKeyOffset]);\n          mptKeyOffset += 1;\n          if (nibble >= 16) {\n            // each element of the path has to be a nibble\n            revert();\n          }\n\n          if (_isEmptyBytesequence(node[nibble])) {\n            // Sanity\n            if (i != stack.length - 1) {\n              // leaf node should be at last level\n              revert();\n            }\n\n            return new bytes(0);\n          } else if (!node[nibble].isList()) {\n            nodeHashHash = node[nibble].payloadKeccak256();\n          } else {\n            nodeHashHash = node[nibble].rlpBytesKeccak256();\n          }\n        } else {\n          // we have consumed the entire mptKey, so we need to look at what's contained in this node.\n\n          // Sanity\n          if (i != stack.length - 1) {\n            // should be at last level\n            revert();\n          }\n\n          return node[16].toBytes();\n        }\n      }\n    }\n  }\n\n  /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\n  ///      Merkle-Patricia-Tries use a weird \"hash function\" that outputs\n  ///      *variable-length* hashes: If the item is shorter than 32 bytes,\n  ///      the MPT hash is the item. Otherwise, the MPT hash is the\n  ///      Keccak-256 hash of the item.\n  ///      The easiest way to compare variable-length byte sequences is\n  ///      to compare their Keccak-256 hashes.\n  /// @param item The RLP item to be hashed.\n  /// @return Keccak-256(MPT-hash(item))\n  function _mptHashHash(\n    RLPReader.RLPItem memory item\n  ) private pure returns (bytes32) {\n    if (item.len < 32) {\n      return item.rlpBytesKeccak256();\n    } else {\n      return keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\n    }\n  }\n\n  function _isEmptyBytesequence(\n    RLPReader.RLPItem memory item\n  ) private pure returns (bool) {\n    if (item.len != 1) {\n      return false;\n    }\n    uint8 b;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      b := byte(0, mload(memPtr))\n    }\n    return b == 0x80 /* empty byte string */;\n  }\n\n  function _merklePatriciaCompactDecode(\n    bytes memory compact\n  ) private pure returns (bool isLeaf, bytes memory nibbles) {\n    require(compact.length > 0);\n    uint256 first_nibble = (uint8(compact[0]) >> 4) & 0xF;\n    uint256 skipNibbles;\n    if (first_nibble == 0) {\n      skipNibbles = 2;\n      isLeaf = false;\n    } else if (first_nibble == 1) {\n      skipNibbles = 1;\n      isLeaf = false;\n    } else if (first_nibble == 2) {\n      skipNibbles = 2;\n      isLeaf = true;\n    } else if (first_nibble == 3) {\n      skipNibbles = 1;\n      isLeaf = true;\n    } else {\n      // Not supposed to happen!\n      revert();\n    }\n    return (isLeaf, _decodeNibbles(compact, skipNibbles));\n  }\n\n  function _decodeNibbles(\n    bytes memory compact,\n    uint256 skipNibbles\n  ) private pure returns (bytes memory nibbles) {\n    require(compact.length > 0);\n\n    uint256 length = compact.length * 2;\n    require(skipNibbles <= length);\n    length -= skipNibbles;\n\n    nibbles = new bytes(length);\n    uint256 nibblesLength = 0;\n\n    for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\n      if (i % 2 == 0) {\n        nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 4) & 0xF);\n      } else {\n        nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 0) & 0xF);\n      }\n      nibblesLength += 1;\n    }\n\n    assert(nibblesLength == nibbles.length);\n  }\n\n  function _sharedPrefixLength(\n    uint256 xsOffset,\n    bytes memory xs,\n    bytes memory ys\n  ) private pure returns (uint256) {\n    uint256 i;\n    for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\n      if (xs[i + xsOffset] != ys[i]) {\n        return i;\n      }\n    }\n    return i;\n  }\n}\n"
    },
    "contracts/Voting/libs/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n * Code copied from: https://github.com/hamdiallam/Solidity-RLP/blob/master/contracts/RLPReader.sol\n */\npragma solidity ^0.8.0;\n\nlibrary RLPReader {\n  uint8 constant STRING_SHORT_START = 0x80;\n  uint8 constant STRING_LONG_START = 0xb8;\n  uint8 constant LIST_SHORT_START = 0xc0;\n  uint8 constant LIST_LONG_START = 0xf8;\n  uint8 constant WORD_SIZE = 32;\n\n  struct RLPItem {\n    uint256 len;\n    uint256 memPtr;\n  }\n\n  struct Iterator {\n    RLPItem item; // Item that's being iterated over.\n    uint256 nextPtr; // Position of the next item in the list.\n  }\n\n  /*\n   * @dev Returns the next element in the iteration. Reverts if it has not next element.\n   * @param self The iterator.\n   * @return The next element in the iteration.\n   */\n  function next(Iterator memory self) internal pure returns (RLPItem memory) {\n    require(hasNext(self));\n\n    uint256 ptr = self.nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    self.nextPtr = ptr + itemLength;\n\n    return RLPItem(itemLength, ptr);\n  }\n\n  /*\n   * @dev Returns true if the iteration has more elements.\n   * @param self The iterator.\n   * @return true if the iteration has more elements.\n   */\n  function hasNext(Iterator memory self) internal pure returns (bool) {\n    RLPItem memory item = self.item;\n    return self.nextPtr < item.memPtr + item.len;\n  }\n\n  /*\n   * @param item RLP encoded bytes\n   */\n  function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n    uint256 memPtr;\n    assembly {\n      memPtr := add(item, 0x20)\n    }\n\n    return RLPItem(item.length, memPtr);\n  }\n\n  /*\n   * @dev Create an iterator. Reverts if item is not a list.\n   * @param self The RLP item.\n   * @return An 'Iterator' over the item.\n   */\n  function iterator(\n    RLPItem memory self\n  ) internal pure returns (Iterator memory) {\n    require(isList(self));\n\n    uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n    return Iterator(self, ptr);\n  }\n\n  /*\n   * @param the RLP item.\n   */\n  function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n    return item.len;\n  }\n\n  /*\n   * @param the RLP item.\n   * @return (memPtr, len) pair: location of the item's payload in memory.\n   */\n  function payloadLocation(\n    RLPItem memory item\n  ) internal pure returns (uint256, uint256) {\n    uint256 offset = _payloadOffset(item.memPtr);\n    uint256 memPtr = item.memPtr + offset;\n    uint256 len = item.len - offset; // data length\n    return (memPtr, len);\n  }\n\n  /*\n   * @param the RLP item.\n   */\n  function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n    (, uint256 len) = payloadLocation(item);\n    return len;\n  }\n\n  /*\n   * @param the RLP item containing the encoded list.\n   */\n  function toList(\n    RLPItem memory item\n  ) internal pure returns (RLPItem[] memory) {\n    require(isList(item));\n\n    uint256 items = numItems(item);\n    RLPItem[] memory result = new RLPItem[](items);\n\n    uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n    uint256 dataLen;\n    for (uint256 i = 0; i < items; i++) {\n      dataLen = _itemLength(memPtr);\n      result[i] = RLPItem(dataLen, memPtr);\n      memPtr = memPtr + dataLen;\n    }\n\n    return result;\n  }\n\n  // @return indicator whether encoded payload is a list. negate this function call for isData.\n  function isList(RLPItem memory item) internal pure returns (bool) {\n    if (item.len == 0) return false;\n\n    uint8 byte0;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < LIST_SHORT_START) return false;\n    return true;\n  }\n\n  /*\n   * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n   * @return keccak256 hash of RLP encoded bytes.\n   */\n  function rlpBytesKeccak256(\n    RLPItem memory item\n  ) internal pure returns (bytes32) {\n    uint256 ptr = item.memPtr;\n    uint256 len = item.len;\n    bytes32 result;\n    assembly {\n      result := keccak256(ptr, len)\n    }\n    return result;\n  }\n\n  /*\n   * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n   * @return keccak256 hash of the item payload.\n   */\n  function payloadKeccak256(\n    RLPItem memory item\n  ) internal pure returns (bytes32) {\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\n    bytes32 result;\n    assembly {\n      result := keccak256(memPtr, len)\n    }\n    return result;\n  }\n\n  /** RLPItem conversions into data types **/\n\n  // @returns raw rlp encoding in bytes\n  function toRlpBytes(\n    RLPItem memory item\n  ) internal pure returns (bytes memory) {\n    bytes memory result = new bytes(item.len);\n    if (result.length == 0) return result;\n\n    uint256 ptr;\n    assembly {\n      ptr := add(0x20, result)\n    }\n\n    copy(item.memPtr, ptr, item.len);\n    return result;\n  }\n\n  // any non-zero byte except \"0x80\" is considered true\n  function toBoolean(RLPItem memory item) internal pure returns (bool) {\n    require(item.len == 1);\n    uint256 result;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      result := byte(0, mload(memPtr))\n    }\n\n    // SEE Github Issue #5.\n    // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n    // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n    // here.\n    if (result == 0 || result == STRING_SHORT_START) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  function toAddress(RLPItem memory item) internal pure returns (address) {\n    // 1 byte for the length prefix\n    require(item.len == 21);\n\n    return address(uint160(toUint(item)));\n  }\n\n  function toUint(RLPItem memory item) internal pure returns (uint256) {\n    require(item.len > 0 && item.len <= 33);\n\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n    uint256 result;\n    assembly {\n      result := mload(memPtr)\n\n      // shift to the correct location if neccesary\n      if lt(len, 32) {\n        result := div(result, exp(256, sub(32, len)))\n      }\n    }\n\n    return result;\n  }\n\n  // enforces 32 byte length\n  function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n    // one byte prefix\n    require(item.len == 33);\n\n    uint256 result;\n    uint256 memPtr = item.memPtr + 1;\n    assembly {\n      result := mload(memPtr)\n    }\n\n    return result;\n  }\n\n  function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n    require(item.len > 0);\n\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\n    bytes memory result = new bytes(len);\n\n    uint256 destPtr;\n    assembly {\n      destPtr := add(0x20, result)\n    }\n\n    copy(memPtr, destPtr, len);\n    return result;\n  }\n\n  /*\n   * Private Helpers\n   */\n\n  // @return number of payload items inside an encoded list.\n  function numItems(RLPItem memory item) private pure returns (uint256) {\n    if (item.len == 0) return 0;\n\n    uint256 count = 0;\n    uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n    uint256 endPtr = item.memPtr + item.len;\n    while (currPtr < endPtr) {\n      currPtr = currPtr + _itemLength(currPtr); // skip over an item\n      count++;\n    }\n\n    return count;\n  }\n\n  // @return entire rlp item byte length\n  function _itemLength(uint256 memPtr) private pure returns (uint256) {\n    uint256 itemLen;\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) {\n      itemLen = 1;\n    } else if (byte0 < STRING_LONG_START) {\n      itemLen = byte0 - STRING_SHORT_START + 1;\n    } else if (byte0 < LIST_SHORT_START) {\n      assembly {\n        let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n        memPtr := add(memPtr, 1) // skip over the first byte\n\n        /* 32 byte word size */\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    } else if (byte0 < LIST_LONG_START) {\n      itemLen = byte0 - LIST_SHORT_START + 1;\n    } else {\n      assembly {\n        let byteLen := sub(byte0, 0xf7)\n        memPtr := add(memPtr, 1)\n\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    }\n\n    return itemLen;\n  }\n\n  // @return number of bytes until the data\n  function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) {\n      return 0;\n    } else if (\n      byte0 < STRING_LONG_START ||\n      (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\n    ) {\n      return 1;\n    } else if (byte0 < LIST_SHORT_START) {\n      // being explicit\n      return byte0 - (STRING_LONG_START - 1) + 1;\n    } else {\n      return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n  }\n\n  /*\n   * @param src Pointer to source\n   * @param dest Pointer to destination\n   * @param len Amount of memory to copy from the source\n   */\n  function copy(uint256 src, uint256 dest, uint256 len) private pure {\n    if (len == 0) return;\n\n    // copy as many word sizes as possible\n    for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n\n      src += WORD_SIZE;\n      dest += WORD_SIZE;\n    }\n\n    if (len > 0) {\n      // left over bytes. Mask is used to remove unwanted bytes from the word\n      uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask)) // zero out src\n        let destpart := and(mload(dest), mask) // retrieve the bytes\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n  }\n}\n"
    },
    "contracts/Voting/libs/StateProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {RLPReader} from './RLPReader.sol';\nimport {MerklePatriciaProofVerifier} from './MerklePatriciaProofVerifier.sol';\n\n/**\n * @title A helper library for verification of Merkle Patricia account and state proofs.\n */\nlibrary StateProofVerifier {\n  using RLPReader for RLPReader.RLPItem;\n  using RLPReader for bytes;\n\n  uint256 constant HEADER_STATE_ROOT_INDEX = 3;\n  uint256 constant HEADER_NUMBER_INDEX = 8;\n  uint256 constant HEADER_TIMESTAMP_INDEX = 11;\n\n  struct BlockHeader {\n    bytes32 hash;\n    bytes32 stateRootHash;\n    uint256 number;\n    uint256 timestamp;\n  }\n\n  struct Account {\n    bool exists;\n    uint256 nonce;\n    uint256 balance;\n    bytes32 storageRoot;\n    bytes32 codeHash;\n  }\n\n  struct SlotValue {\n    bool exists;\n    uint256 value;\n  }\n\n  /**\n   * @notice Parses block header and verifies its presence onchain within the latest 256 blocks.\n   * @param _headerRlpBytes RLP-encoded block header.\n   */\n  function verifyBlockHeader(\n    bytes memory _headerRlpBytes,\n    bytes32 _blockHash\n  ) internal pure returns (BlockHeader memory) {\n    BlockHeader memory header = parseBlockHeader(_headerRlpBytes);\n    require(header.hash == _blockHash, 'blockhash mismatch');\n    return header;\n  }\n\n  /**\n   * @notice Parses RLP-encoded block header.\n   * @param _headerRlpBytes RLP-encoded block header.\n   */\n  function parseBlockHeader(\n    bytes memory _headerRlpBytes\n  ) internal pure returns (BlockHeader memory) {\n    BlockHeader memory result;\n    RLPReader.RLPItem[] memory headerFields = _headerRlpBytes\n      .toRlpItem()\n      .toList();\n\n    require(headerFields.length > HEADER_TIMESTAMP_INDEX);\n\n    result.stateRootHash = bytes32(\n      headerFields[HEADER_STATE_ROOT_INDEX].toUint()\n    );\n    result.number = headerFields[HEADER_NUMBER_INDEX].toUint();\n    result.timestamp = headerFields[HEADER_TIMESTAMP_INDEX].toUint();\n    result.hash = keccak256(_headerRlpBytes);\n\n    return result;\n  }\n\n  /**\n   * @notice Verifies Merkle Patricia proof of an account and extracts the account fields.\n   *\n   * @param _addressHash Keccak256 hash of the address corresponding to the account.\n   * @param _stateRootHash MPT root hash of the Ethereum state trie.\n   */\n  function extractAccountFromProof(\n    bytes32 _addressHash, // keccak256(abi.encodePacked(address))\n    bytes32 _stateRootHash,\n    RLPReader.RLPItem[] memory _proof\n  ) internal pure returns (Account memory) {\n    bytes memory acctRlpBytes = MerklePatriciaProofVerifier.extractProofValue(\n      _stateRootHash,\n      abi.encodePacked(_addressHash),\n      _proof\n    );\n    Account memory account;\n\n    if (acctRlpBytes.length == 0) {\n      return account;\n    }\n\n    RLPReader.RLPItem[] memory acctFields = acctRlpBytes.toRlpItem().toList();\n    require(acctFields.length == 4);\n\n    account.exists = true;\n    account.nonce = acctFields[0].toUint();\n    account.balance = acctFields[1].toUint();\n    account.storageRoot = bytes32(acctFields[2].toUint());\n    account.codeHash = bytes32(acctFields[3].toUint());\n\n    return account;\n  }\n\n  /**\n   * @notice Verifies Merkle Patricia proof of a slot and extracts the slot's value.\n   *\n   * @param _slotHash Keccak256 hash of the slot position.\n   * @param _storageRootHash MPT root hash of the account's storage trie.\n   */\n  function extractSlotValueFromProof(\n    bytes32 _slotHash,\n    bytes32 _storageRootHash,\n    RLPReader.RLPItem[] memory _proof\n  ) internal pure returns (SlotValue memory) {\n    bytes memory valueRlpBytes = MerklePatriciaProofVerifier.extractProofValue(\n      _storageRootHash,\n      abi.encodePacked(_slotHash),\n      _proof\n    );\n\n    SlotValue memory value;\n\n    if (valueRlpBytes.length != 0) {\n      value.exists = true;\n      value.value = valueRlpBytes.toRlpItem().toUint();\n    }\n\n    return value;\n  }\n}\n"
    },
    "contracts/Voting/MerklePatriciaProofVerifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/**\n * Copied from https://github.com/lidofinance/curve-merkle-oracle/blob/main/contracts/MerklePatriciaProofVerifier.sol\n */\npragma solidity ^0.8.0;\n\nimport {RLPReader} from './RLPReader.sol';\n\nlibrary MerklePatriciaProofVerifier {\n  using RLPReader for RLPReader.RLPItem;\n  using RLPReader for bytes;\n\n  /// @dev Validates a Merkle-Patricia-Trie proof.\n  ///      If the proof proves the inclusion of some key-value pair in the\n  ///      trie, the value is returned. Otherwise, i.e. if the proof proves\n  ///      the exclusion of a key from the trie, an empty byte array is\n  ///      returned.\n  /// @param rootHash is the Keccak-256 hash of the root node of the MPT.\n  /// @param path is the key of the node whose inclusion/exclusion we are\n  ///        proving.\n  /// @param stack is the stack of MPT nodes (starting with the root) that\n  ///        need to be traversed during verification.\n  /// @return value whose inclusion is proved or an empty byte array for\n  ///         a proof of exclusion\n  function extractProofValue(\n    bytes32 rootHash,\n    bytes memory path,\n    RLPReader.RLPItem[] memory stack\n  ) internal pure returns (bytes memory value) {\n    bytes memory mptKey = _decodeNibbles(path, 0);\n    uint256 mptKeyOffset = 0;\n\n    bytes32 nodeHashHash;\n    RLPReader.RLPItem[] memory node;\n\n    RLPReader.RLPItem memory rlpValue;\n\n    if (stack.length == 0) {\n      // Root hash of empty Merkle-Patricia-Trie\n      require(\n        rootHash ==\n          0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\n      );\n      return new bytes(0);\n    }\n\n    // Traverse stack of nodes starting at root.\n    for (uint256 i = 0; i < stack.length; i++) {\n      // We use the fact that an rlp encoded list consists of some\n      // encoding of its length plus the concatenation of its\n      // *rlp-encoded* items.\n\n      // The root node is hashed with Keccak-256 ...\n      if (i == 0 && rootHash != stack[i].rlpBytesKeccak256()) {\n        revert();\n      }\n      // ... whereas all other nodes are hashed with the MPT\n      // hash function.\n      if (i != 0 && nodeHashHash != _mptHashHash(stack[i])) {\n        revert();\n      }\n      // We verified that stack[i] has the correct hash, so we\n      // may safely decode it.\n      node = stack[i].toList();\n\n      if (node.length == 2) {\n        // Extension or Leaf node\n\n        bool isLeaf;\n        bytes memory nodeKey;\n        (isLeaf, nodeKey) = _merklePatriciaCompactDecode(node[0].toBytes());\n\n        uint256 prefixLength = _sharedPrefixLength(\n          mptKeyOffset,\n          mptKey,\n          nodeKey\n        );\n        mptKeyOffset += prefixLength;\n\n        if (prefixLength < nodeKey.length) {\n          // Proof claims divergent extension or leaf. (Only\n          // relevant for proofs of exclusion.)\n          // An Extension/Leaf node is divergent iff it \"skips\" over\n          // the point at which a Branch node should have been had the\n          // excluded key been included in the trie.\n          // Example: Imagine a proof of exclusion for path [1, 4],\n          // where the current node is a Leaf node with\n          // path [1, 3, 3, 7]. For [1, 4] to be included, there\n          // should have been a Branch node at [1] with a child\n          // at 3 and a child at 4.\n\n          // Sanity check\n          if (i < stack.length - 1) {\n            // divergent node must come last in proof\n            revert();\n          }\n\n          return new bytes(0);\n        }\n\n        if (isLeaf) {\n          // Sanity check\n          if (i < stack.length - 1) {\n            // leaf node must come last in proof\n            revert();\n          }\n\n          if (mptKeyOffset < mptKey.length) {\n            return new bytes(0);\n          }\n\n          rlpValue = node[1];\n          return rlpValue.toBytes();\n        } else {\n          // extension\n          // Sanity check\n          if (i == stack.length - 1) {\n            // shouldn't be at last level\n            revert();\n          }\n\n          if (!node[1].isList()) {\n            // rlp(child) was at least 32 bytes. node[1] contains\n            // Keccak256(rlp(child)).\n            nodeHashHash = node[1].payloadKeccak256();\n          } else {\n            // rlp(child) was less than 32 bytes. node[1] contains\n            // rlp(child).\n            nodeHashHash = node[1].rlpBytesKeccak256();\n          }\n        }\n      } else if (node.length == 17) {\n        // Branch node\n\n        if (mptKeyOffset != mptKey.length) {\n          // we haven't consumed the entire path, so we need to look at a child\n          uint8 nibble = uint8(mptKey[mptKeyOffset]);\n          mptKeyOffset += 1;\n          if (nibble >= 16) {\n            // each element of the path has to be a nibble\n            revert();\n          }\n\n          if (_isEmptyBytesequence(node[nibble])) {\n            // Sanity\n            if (i != stack.length - 1) {\n              // leaf node should be at last level\n              revert();\n            }\n\n            return new bytes(0);\n          } else if (!node[nibble].isList()) {\n            nodeHashHash = node[nibble].payloadKeccak256();\n          } else {\n            nodeHashHash = node[nibble].rlpBytesKeccak256();\n          }\n        } else {\n          // we have consumed the entire mptKey, so we need to look at what's contained in this node.\n\n          // Sanity\n          if (i != stack.length - 1) {\n            // should be at last level\n            revert();\n          }\n\n          return node[16].toBytes();\n        }\n      }\n    }\n  }\n\n  /// @dev Computes the hash of the Merkle-Patricia-Trie hash of the RLP item.\n  ///      Merkle-Patricia-Tries use a weird \"hash function\" that outputs\n  ///      *variable-length* hashes: If the item is shorter than 32 bytes,\n  ///      the MPT hash is the item. Otherwise, the MPT hash is the\n  ///      Keccak-256 hash of the item.\n  ///      The easiest way to compare variable-length byte sequences is\n  ///      to compare their Keccak-256 hashes.\n  /// @param item The RLP item to be hashed.\n  /// @return Keccak-256(MPT-hash(item))\n  function _mptHashHash(\n    RLPReader.RLPItem memory item\n  ) private pure returns (bytes32) {\n    if (item.len < 32) {\n      return item.rlpBytesKeccak256();\n    } else {\n      return keccak256(abi.encodePacked(item.rlpBytesKeccak256()));\n    }\n  }\n\n  function _isEmptyBytesequence(\n    RLPReader.RLPItem memory item\n  ) private pure returns (bool) {\n    if (item.len != 1) {\n      return false;\n    }\n    uint8 b;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      b := byte(0, mload(memPtr))\n    }\n    return b == 0x80 /* empty byte string */;\n  }\n\n  function _merklePatriciaCompactDecode(\n    bytes memory compact\n  ) private pure returns (bool isLeaf, bytes memory nibbles) {\n    require(compact.length > 0);\n    uint256 first_nibble = (uint8(compact[0]) >> 4) & 0xF;\n    uint256 skipNibbles;\n    if (first_nibble == 0) {\n      skipNibbles = 2;\n      isLeaf = false;\n    } else if (first_nibble == 1) {\n      skipNibbles = 1;\n      isLeaf = false;\n    } else if (first_nibble == 2) {\n      skipNibbles = 2;\n      isLeaf = true;\n    } else if (first_nibble == 3) {\n      skipNibbles = 1;\n      isLeaf = true;\n    } else {\n      // Not supposed to happen!\n      revert();\n    }\n    return (isLeaf, _decodeNibbles(compact, skipNibbles));\n  }\n\n  function _decodeNibbles(\n    bytes memory compact,\n    uint256 skipNibbles\n  ) private pure returns (bytes memory nibbles) {\n    require(compact.length > 0);\n\n    uint256 length = compact.length * 2;\n    require(skipNibbles <= length);\n    length -= skipNibbles;\n\n    nibbles = new bytes(length);\n    uint256 nibblesLength = 0;\n\n    for (uint256 i = skipNibbles; i < skipNibbles + length; i += 1) {\n      if (i % 2 == 0) {\n        nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 4) & 0xF);\n      } else {\n        nibbles[nibblesLength] = bytes1((uint8(compact[i / 2]) >> 0) & 0xF);\n      }\n      nibblesLength += 1;\n    }\n\n    assert(nibblesLength == nibbles.length);\n  }\n\n  function _sharedPrefixLength(\n    uint256 xsOffset,\n    bytes memory xs,\n    bytes memory ys\n  ) private pure returns (uint256) {\n    uint256 i;\n    for (i = 0; i + xsOffset < xs.length && i < ys.length; i++) {\n      if (xs[i + xsOffset] != ys[i]) {\n        return i;\n      }\n    }\n    return i;\n  }\n}\n"
    },
    "contracts/Voting/RLPReader.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\n\n/*\n * @author Hamdi Allam hamdi.allam97@gmail.com\n * Please reach out with any questions or concerns\n * Code copied from: https://github.com/hamdiallam/Solidity-RLP/blob/master/contracts/RLPReader.sol\n */\npragma solidity ^0.8.0;\n\nlibrary RLPReader {\n  uint8 constant STRING_SHORT_START = 0x80;\n  uint8 constant STRING_LONG_START = 0xb8;\n  uint8 constant LIST_SHORT_START = 0xc0;\n  uint8 constant LIST_LONG_START = 0xf8;\n  uint8 constant WORD_SIZE = 32;\n\n  struct RLPItem {\n    uint256 len;\n    uint256 memPtr;\n  }\n\n  struct Iterator {\n    RLPItem item; // Item that's being iterated over.\n    uint256 nextPtr; // Position of the next item in the list.\n  }\n\n  /*\n   * @dev Returns the next element in the iteration. Reverts if it has not next element.\n   * @param self The iterator.\n   * @return The next element in the iteration.\n   */\n  function next(Iterator memory self) internal pure returns (RLPItem memory) {\n    require(hasNext(self));\n\n    uint256 ptr = self.nextPtr;\n    uint256 itemLength = _itemLength(ptr);\n    self.nextPtr = ptr + itemLength;\n\n    return RLPItem(itemLength, ptr);\n  }\n\n  /*\n   * @dev Returns true if the iteration has more elements.\n   * @param self The iterator.\n   * @return true if the iteration has more elements.\n   */\n  function hasNext(Iterator memory self) internal pure returns (bool) {\n    RLPItem memory item = self.item;\n    return self.nextPtr < item.memPtr + item.len;\n  }\n\n  /*\n   * @param item RLP encoded bytes\n   */\n  function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\n    uint256 memPtr;\n    assembly {\n      memPtr := add(item, 0x20)\n    }\n\n    return RLPItem(item.length, memPtr);\n  }\n\n  /*\n   * @dev Create an iterator. Reverts if item is not a list.\n   * @param self The RLP item.\n   * @return An 'Iterator' over the item.\n   */\n  function iterator(\n    RLPItem memory self\n  ) internal pure returns (Iterator memory) {\n    require(isList(self));\n\n    uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\n    return Iterator(self, ptr);\n  }\n\n  /*\n   * @param the RLP item.\n   */\n  function rlpLen(RLPItem memory item) internal pure returns (uint256) {\n    return item.len;\n  }\n\n  /*\n   * @param the RLP item.\n   * @return (memPtr, len) pair: location of the item's payload in memory.\n   */\n  function payloadLocation(\n    RLPItem memory item\n  ) internal pure returns (uint256, uint256) {\n    uint256 offset = _payloadOffset(item.memPtr);\n    uint256 memPtr = item.memPtr + offset;\n    uint256 len = item.len - offset; // data length\n    return (memPtr, len);\n  }\n\n  /*\n   * @param the RLP item.\n   */\n  function payloadLen(RLPItem memory item) internal pure returns (uint256) {\n    (, uint256 len) = payloadLocation(item);\n    return len;\n  }\n\n  /*\n   * @param the RLP item containing the encoded list.\n   */\n  function toList(\n    RLPItem memory item\n  ) internal pure returns (RLPItem[] memory) {\n    require(isList(item));\n\n    uint256 items = numItems(item);\n    RLPItem[] memory result = new RLPItem[](items);\n\n    uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\n    uint256 dataLen;\n    for (uint256 i = 0; i < items; i++) {\n      dataLen = _itemLength(memPtr);\n      result[i] = RLPItem(dataLen, memPtr);\n      memPtr = memPtr + dataLen;\n    }\n\n    return result;\n  }\n\n  // @return indicator whether encoded payload is a list. negate this function call for isData.\n  function isList(RLPItem memory item) internal pure returns (bool) {\n    if (item.len == 0) return false;\n\n    uint8 byte0;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < LIST_SHORT_START) return false;\n    return true;\n  }\n\n  /*\n   * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\n   * @return keccak256 hash of RLP encoded bytes.\n   */\n  function rlpBytesKeccak256(\n    RLPItem memory item\n  ) internal pure returns (bytes32) {\n    uint256 ptr = item.memPtr;\n    uint256 len = item.len;\n    bytes32 result;\n    assembly {\n      result := keccak256(ptr, len)\n    }\n    return result;\n  }\n\n  /*\n   * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\n   * @return keccak256 hash of the item payload.\n   */\n  function payloadKeccak256(\n    RLPItem memory item\n  ) internal pure returns (bytes32) {\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\n    bytes32 result;\n    assembly {\n      result := keccak256(memPtr, len)\n    }\n    return result;\n  }\n\n  /** RLPItem conversions into data types **/\n\n  // @returns raw rlp encoding in bytes\n  function toRlpBytes(\n    RLPItem memory item\n  ) internal pure returns (bytes memory) {\n    bytes memory result = new bytes(item.len);\n    if (result.length == 0) return result;\n\n    uint256 ptr;\n    assembly {\n      ptr := add(0x20, result)\n    }\n\n    copy(item.memPtr, ptr, item.len);\n    return result;\n  }\n\n  // any non-zero byte except \"0x80\" is considered true\n  function toBoolean(RLPItem memory item) internal pure returns (bool) {\n    require(item.len == 1);\n    uint256 result;\n    uint256 memPtr = item.memPtr;\n    assembly {\n      result := byte(0, mload(memPtr))\n    }\n\n    // SEE Github Issue #5.\n    // Summary: Most commonly used RLP libraries (i.e Geth) will encode\n    // \"0\" as \"0x80\" instead of as \"0\". We handle this edge case explicitly\n    // here.\n    if (result == 0 || result == STRING_SHORT_START) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  function toAddress(RLPItem memory item) internal pure returns (address) {\n    // 1 byte for the length prefix\n    require(item.len == 21);\n\n    return address(uint160(toUint(item)));\n  }\n\n  function toUint(RLPItem memory item) internal pure returns (uint256) {\n    require(item.len > 0 && item.len <= 33);\n\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\n\n    uint256 result;\n    assembly {\n      result := mload(memPtr)\n\n      // shift to the correct location if neccesary\n      if lt(len, 32) {\n        result := div(result, exp(256, sub(32, len)))\n      }\n    }\n\n    return result;\n  }\n\n  // enforces 32 byte length\n  function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\n    // one byte prefix\n    require(item.len == 33);\n\n    uint256 result;\n    uint256 memPtr = item.memPtr + 1;\n    assembly {\n      result := mload(memPtr)\n    }\n\n    return result;\n  }\n\n  function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\n    require(item.len > 0);\n\n    (uint256 memPtr, uint256 len) = payloadLocation(item);\n    bytes memory result = new bytes(len);\n\n    uint256 destPtr;\n    assembly {\n      destPtr := add(0x20, result)\n    }\n\n    copy(memPtr, destPtr, len);\n    return result;\n  }\n\n  /*\n   * Private Helpers\n   */\n\n  // @return number of payload items inside an encoded list.\n  function numItems(RLPItem memory item) private pure returns (uint256) {\n    if (item.len == 0) return 0;\n\n    uint256 count = 0;\n    uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\n    uint256 endPtr = item.memPtr + item.len;\n    while (currPtr < endPtr) {\n      currPtr = currPtr + _itemLength(currPtr); // skip over an item\n      count++;\n    }\n\n    return count;\n  }\n\n  // @return entire rlp item byte length\n  function _itemLength(uint256 memPtr) private pure returns (uint256) {\n    uint256 itemLen;\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) {\n      itemLen = 1;\n    } else if (byte0 < STRING_LONG_START) {\n      itemLen = byte0 - STRING_SHORT_START + 1;\n    } else if (byte0 < LIST_SHORT_START) {\n      assembly {\n        let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\n        memPtr := add(memPtr, 1) // skip over the first byte\n\n        /* 32 byte word size */\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    } else if (byte0 < LIST_LONG_START) {\n      itemLen = byte0 - LIST_SHORT_START + 1;\n    } else {\n      assembly {\n        let byteLen := sub(byte0, 0xf7)\n        memPtr := add(memPtr, 1)\n\n        let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\n        itemLen := add(dataLen, add(byteLen, 1))\n      }\n    }\n\n    return itemLen;\n  }\n\n  // @return number of bytes until the data\n  function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\n    uint256 byte0;\n    assembly {\n      byte0 := byte(0, mload(memPtr))\n    }\n\n    if (byte0 < STRING_SHORT_START) {\n      return 0;\n    } else if (\n      byte0 < STRING_LONG_START ||\n      (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START)\n    ) {\n      return 1;\n    } else if (byte0 < LIST_SHORT_START) {\n      // being explicit\n      return byte0 - (STRING_LONG_START - 1) + 1;\n    } else {\n      return byte0 - (LIST_LONG_START - 1) + 1;\n    }\n  }\n\n  /*\n   * @param src Pointer to source\n   * @param dest Pointer to destination\n   * @param len Amount of memory to copy from the source\n   */\n  function copy(uint256 src, uint256 dest, uint256 len) private pure {\n    if (len == 0) return;\n\n    // copy as many word sizes as possible\n    for (; len >= WORD_SIZE; len -= WORD_SIZE) {\n      assembly {\n        mstore(dest, mload(src))\n      }\n\n      src += WORD_SIZE;\n      dest += WORD_SIZE;\n    }\n\n    if (len > 0) {\n      // left over bytes. Mask is used to remove unwanted bytes from the word\n      uint256 mask = 256 ** (WORD_SIZE - len) - 1;\n      assembly {\n        let srcpart := and(mload(src), not(mask)) // zero out src\n        let destpart := and(mload(dest), mask) // retrieve the bytes\n        mstore(dest, or(destpart, srcpart))\n      }\n    }\n  }\n}\n"
    },
    "contracts/Voting/VoteWithProof.sol": {
      "content": "//  SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\nimport { MerklePatriciaProofVerifier } from \"./MerklePatriciaProofVerifier.sol\";\nimport { RLPReader } from \"./RLPReader.sol\";\nimport { StateProofVerifier } from \"./libs/StateProofVerifier.sol\";\nimport { SlotUtils } from \"./libraries/SlotUtils.sol\";\n\nimport { IVotingMachineWithProofs, IDataWarehouse, IVotingStrategy } from \"./IVotingMachineWithProofs.sol\";\n\ncontract VoteWithProof {\n    using RLPReader for bytes;\n    using RLPReader for RLPReader.RLPItem;\n    mapping(uint256 => ProposalVoteConfiguration) internal _proposalsVoteConfiguration;\n\n    /**\n     * @notice Object with the necessary information to process a vote\n     * @param underlyingAsset address of the token on L2, used for voting\n     * @param slot base storage position where the balance on underlyingAsset contract resides on L2. (Normally position 0)\n     * @param proof bytes of the generated proof on L2 with the slot information of underlying asset.\n     */\n    struct VotingBalanceProof {\n        address underlyingAsset;\n        uint128 slot;\n        bytes proof;\n    }\n\n    /**\n   * @notice vote configuration passed from l1\n   * @param votingDuration duration in seconds of the vote for a proposal\n   * @param l1BlockHash hash of the block on L1 from the block when the proposal was activated for voting (sent to voting machine)\n            this block hash is used to delimit from when the voting power is accounted for voting\n   */\n    struct ProposalVoteConfiguration {\n        uint24 votingDuration;\n        bytes32 l1ProposalBlockHash;\n    }\n\n    struct SlotValue {\n        bool exists;\n        uint256 value;\n    }\n\n    address public DATA_WAREHOUSE;\n    address public VOTING_STRATEGY;\n\n    event VoteEmitted(uint256);\n\n    constructor(address _DATA_WAREHOUSE, address _VOTING_STRATEGY) {\n        DATA_WAREHOUSE = _DATA_WAREHOUSE;\n        VOTING_STRATEGY = _VOTING_STRATEGY;\n    }\n\n    function castVote(\n        address voter,\n        uint256 proposalId,\n        uint8 vote, // 0 => against, 1 => for or 2 => abstain\n        VotingBalanceProof[] calldata votingBalanceProofs\n    ) external {\n        require(msg.sender == voter, \"Invalid address\");\n        bytes memory storageProof = bytes(\n            \"0xf901d1a0c8567507af18075a60a65318f220a1a83bd2d071f79dadbfe6dcc9b3a4f5ea0ea00b60709351ef430468859195ed1be3ca75473a03aa88a9bc69a1d927d54ed8dda074d50984b3df382671595b03a667c458c357ee15406dd5ba24d1ec21ff0a87fda04d3ffdf20b93f00d01b77c691e6c5631de65b02fbe30d8972a1424517eaad4d9a0f73477ea70ad8460feedb08276bf4c753025b4d41d4b6dcad0d7ed2ea5038c8180a0a34bbd038133d8c421d89abc10df72e993233b87a070398d79d6e97a32ad0f22a08efddd63066bb9929ada0ee72715564160530ae169f7a6a23528c76a19aee8b4a062dcdf3c31cc944c25bbcf1d091f318a7cddbfacbada192e5e86e48c9f136d7680a0981bc02749b76de7a1a97fc824d5057b78aaa66f12c1eedb0b368d461aeafd83a0501d1ae475ff24198f4abab21903f93f2c4b0c4c462a4952444b8927a96428c0a0a44ebf58173c7ac20500eaf61d6fb9fc2069e1071e1118a2560cc0897e7c1fc3a0f35d1ef5f568d8119b286bbc92c6fb235b3cb4fcf295a35b1b143a5244642e0ea039d3539622f59df774f20f6c093a4546ece356258199248d64bb664a8f35aca4a08d5035887d69bf95a9f0346631f4703010f36023aafb04b0dbd98d4b41154d8c80\"\n        );\n        bytes memory blockHash = bytes(\"0xf1848ec063ed46077992bc5ecb123c6b480844cf36bff5f89cb3dad112ff2fb6\");\n        bytes32 proofPath = 0x84d95bdcd12650905d6c3e566c5b378c17649cb735f88c36140181cc8705827c; //keccak256(abi.encodePacked(0));\n        bytes32 root = 0x67553c72407047d60b56a87df38e6dfbd481c70ffee16790036d39396307faa0;\n        bytes memory valueRlpBytes = MerklePatriciaProofVerifier.extractProofValue(\n            root,\n            abi.encodePacked(proofPath),\n            storageProof.toRlpItem().toList()\n        );\n\n        SlotValue memory value;\n\n        if (valueRlpBytes.length != 0) {\n            value.exists = true;\n            value.value = valueRlpBytes.toRlpItem().toUint();\n        }\n    }\n\n    /**\n    * @notice method to cast a vote on a proposal specified by its id\n    * @param voter address with the voting power\n    * @param proposalId id of the proposal on which the vote will be cast\n    * @param support boolean indicating if the vote is in favor or against the proposal\n    * @param votingBalanceProofs list of objects containing the information necessary to vote using the tokens\n             allowed on the voting strategy.\n    * @dev A vote does not need to use all the tokens allowed, can be a subset\n    */\n    function submitVote(\n        address voter,\n        uint256 proposalId,\n        bool support,\n        VotingBalanceProof calldata votingBalanceProofs\n    ) external {\n        // Proposal storage proposal = _proposals[proposalId];\n        // require(\n        //   _getProposalState(proposal) == ProposalState.Active,\n        //   Errors.PROPOSAL_VOTE_NOT_IN_ACTIVE_STATE\n        // );\n\n        // Vote storage vote = proposal.votes[voter];\n        // require(vote.votingPower == 0, Errors.PROPOSAL_VOTE_ALREADY_EXISTS);\n\n        ProposalVoteConfiguration memory voteConfig = _proposalsVoteConfiguration[proposalId];\n\n        uint256 votingPower;\n        StateProofVerifier.SlotValue memory balanceVotingPower;\n            balanceVotingPower = IDataWarehouse(DATA_WAREHOUSE).getStorage(\n                votingBalanceProofs.underlyingAsset,\n                voteConfig.l1ProposalBlockHash,\n                SlotUtils.getAccountSlotHash(voter, votingBalanceProofs.slot),\n                votingBalanceProofs.proof\n            );\n\n            // if (balanceVotingPower.value != 0) {\n            //     votingPower += IVotingStrategy(address(VOTING_STRATEGY)).getVotingPower(\n            //         votingBalanceProofs.underlyingAsset,\n            //         votingBalanceProofs.slot,\n            //         balanceVotingPower.value,\n            //         voteConfig.l1ProposalBlockHash\n            //     );\n            // }\n        \n\n        if (support) {}\n\n        emit VoteEmitted(votingPower);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view virtual returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(Address.isContract(IBeacon(newBeacon).implementation()), \"ERC1967: beacon implementation is not a contract\");\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n\n    constructor (address initialOwner) Ownable(initialOwner) {}\n\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0-rc.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/openzeppelin/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/OptimizedTransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../openzeppelin/proxy/ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract OptimizedTransparentUpgradeableProxy is ERC1967Proxy {\n    address internal immutable _ADMIN;\n\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n        _ADMIN = admin_;\n\n        // still store it to work with EIP-1967\n        bytes32 slot = _ADMIN_SLOT;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            sstore(slot, admin_)\n        }\n        emit AdminChanged(address(0), admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n\n    function _getAdmin() internal view virtual override returns (address) {\n        return _ADMIN;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
