{
  "language": "Solidity",
  "sources": {
    "@venusprotocol/solidity-utilities/contracts/validators.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\n\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\nerror ZeroAddressNotAllowed();\n\n/// @notice Thrown if the supplied value is 0 where it is not allowed\nerror ZeroValueNotAllowed();\n\n/// @notice Checks if the provided address is nonzero, reverts otherwise\n/// @param address_ Address to check\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\nfunction ensureNonzeroAddress(address address_) pure {\n    if (address_ == address(0)) {\n        revert ZeroAddressNotAllowed();\n    }\n}\n\n/// @notice Checks if the provided value is nonzero, reverts otherwise\n/// @param value_ Value to check\n/// @custom:error ZeroValueNotAllowed is thrown if the provided value is 0\nfunction ensureNonzeroValue(uint256 value_) pure {\n    if (value_ == 0) {\n        revert ZeroValueNotAllowed();\n    }\n}\n"
    },
    "contracts/Governance/TimelockV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\nimport { ensureNonzeroAddress } from \"@venusprotocol/solidity-utilities/contracts/validators.sol\";\n\n/**\n * @title TimelockV8\n * @author Venus\n * @notice The Timelock contract using solidity V8.\n * This contract also differs from the original timelock because it has a virtual function to get minimum delays\n * and allow test deployments to override the value.\n */\ncontract TimelockV8 {\n    /// @notice Required period to execute a proposal transaction\n    uint256 private constant DEFAULT_GRACE_PERIOD = 14 days;\n\n    /// @notice Minimum amount of time a proposal transaction must be queued\n    uint256 private constant DEFAULT_MINIMUM_DELAY = 1 seconds;\n\n    /// @notice Maximum amount of time a proposal transaction must be queued\n    uint256 private constant DEFAULT_MAXIMUM_DELAY = 30 days;\n\n    /// @notice Timelock admin authorized to queue and execute transactions\n    address public admin;\n\n    /// @notice Account proposed as the next admin\n    address public pendingAdmin;\n\n    /// @notice Period for a proposal transaction to be queued\n    uint256 public delay;\n\n    /// @notice Mapping of queued transactions\n    mapping(bytes32 => bool) public queuedTransactions;\n\n    /// @notice Event emitted when a new admin is accepted\n    event NewAdmin(address indexed oldAdmin, address indexed newAdmin);\n\n    /// @notice Event emitted when a new admin is proposed\n    event NewPendingAdmin(address indexed newPendingAdmin);\n\n    /// @notice Event emitted when a new delay is proposed\n    event NewDelay(uint256 indexed oldDelay, uint256 indexed newDelay);\n\n    /// @notice Event emitted when a proposal transaction has been cancelled\n    event CancelTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    /// @notice Event emitted when a proposal transaction has been executed\n    event ExecuteTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    /// @notice Event emitted when a proposal transaction has been queued\n    event QueueTransaction(\n        bytes32 indexed txHash,\n        address indexed target,\n        uint256 value,\n        string signature,\n        bytes data,\n        uint256 eta\n    );\n\n    constructor(address admin_, uint256 delay_) {\n        require(delay_ >= MINIMUM_DELAY(), \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY(), \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        ensureNonzeroAddress(admin_);\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    fallback() external payable {}\n\n    /**\n     * @notice Setter for the transaction queue delay\n     * @param delay_ The new delay period for the transaction queue\n     * @custom:access Sender must be Timelock itself\n     * @custom:event Emit NewDelay with old and new delay\n     */\n    function setDelay(uint256 delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= MINIMUM_DELAY(), \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY(), \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        emit NewDelay(delay, delay_);\n        delay = delay_;\n    }\n\n    /**\n     * @notice Return grace period\n     * @return The duration of the grace period, specified as a uint256 value.\n     */\n    function GRACE_PERIOD() public view virtual returns (uint256) {\n        return DEFAULT_GRACE_PERIOD;\n    }\n\n    /**\n     * @notice Return required minimum delay\n     * @return Minimum delay\n     */\n    function MINIMUM_DELAY() public view virtual returns (uint256) {\n        return DEFAULT_MINIMUM_DELAY;\n    }\n\n    /**\n     * @notice Return required maximum delay\n     * @return Maximum delay\n     */\n    function MAXIMUM_DELAY() public view virtual returns (uint256) {\n        return DEFAULT_MAXIMUM_DELAY;\n    }\n\n    /**\n     * @notice Method for accepting a proposed admin\n     * @custom:access Sender must be pending admin\n     * @custom:event Emit NewAdmin with old and new admin\n     */\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        emit NewAdmin(admin, msg.sender);\n        admin = msg.sender;\n        pendingAdmin = address(0);\n    }\n\n    /**\n     * @notice Method to propose a new admin authorized to call timelock functions. This should be the Governor Contract\n     * @param pendingAdmin_ Address of the proposed admin\n     * @custom:access Sender must be Timelock contract itself or admin\n     * @custom:event Emit NewPendingAdmin with new pending admin\n     */\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(\n            msg.sender == address(this) || msg.sender == admin,\n            \"Timelock::setPendingAdmin: Call must come from Timelock.\"\n        );\n        ensureNonzeroAddress(pendingAdmin_);\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    /**\n     * @notice Called for each action when queuing a proposal\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature Signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @return Hash of the queued transaction\n     * @custom:access Sender must be admin\n     * @custom:event Emit QueueTransaction\n     */\n    function queueTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(\n            eta >= getBlockTimestamp() + delay,\n            \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\"\n        );\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(!queuedTransactions[txHash], \"Timelock::queueTransaction: transaction already queued.\");\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    /**\n     * @notice Called to cancel a queued transaction\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature Signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @custom:access Sender must be admin\n     * @custom:event Emit CancelTransaction\n     */\n    function cancelTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::cancelTransaction: transaction is not queued yet.\");\n        delete (queuedTransactions[txHash]);\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    /**\n     * @notice Called to execute a queued transaction\n     * @param target Address of the contract with the method to be called\n     * @param value Native token amount sent with the transaction\n     * @param signature Signature of the function to be called\n     * @param data Arguments to be passed to the function when called\n     * @param eta Timestamp after which the transaction can be executed\n     * @return Result of function call\n     * @custom:access Sender must be admin\n     * @custom:event Emit ExecuteTransaction\n     */\n    function executeTransaction(\n        address target,\n        uint256 value,\n        string calldata signature,\n        bytes calldata data,\n        uint256 eta\n    ) public returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta + GRACE_PERIOD(), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        delete (queuedTransactions[txHash]);\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{ value: value }(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    /**\n     * @notice Returns the current block timestamp\n     * @return The current block timestamp\n     */\n    function getBlockTimestamp() internal view returns (uint256) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}\n"
    },
    "contracts/test/TestTimelockV8.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity 0.8.25;\nimport { TimelockV8 } from \"../Governance/TimelockV8.sol\";\n\ncontract TestTimelockV8 is TimelockV8 {\n    constructor(address admin_, uint256 delay_) public TimelockV8(admin_, delay_) {}\n\n    function GRACE_PERIOD() public view override returns (uint256) {\n        return 1;\n    }\n\n    function MINIMUM_DELAY() public view override returns (uint256) {\n        return 1;\n    }\n\n    function MAXIMUM_DELAY() public view override returns (uint256) {\n        return 1 hours;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10000
    },
    "evmVersion": "shanghai",
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
